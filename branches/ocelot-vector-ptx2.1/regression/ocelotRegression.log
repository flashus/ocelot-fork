INFO     Reading in test file /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/regression/ocelotRegressionTests.txt
INFO      Found the following tests:
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLexer
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestParser
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestEmulator
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestInstructions
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestKernels
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestDataflowGraph
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLLVMInstructions
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestPTXToLLVMTranslator
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLLVMKernels
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaMalloc
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaTexture2D
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaTextureArray
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaGlobals
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestDeviceSwitching
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaSequence
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCalVectorScale
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestPTXAssembly
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestFunctionCall
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestIndirectFunctionCall
INFO       /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestConvergence
INFO     ==== INDIVIDUAL TEST RESULTS ====

INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLexer -i ../tests/ptx 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestPTXToLLVMTranslator -i ../tests/ptx 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaTexture2D 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCalVectorScale 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestKernels 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestInstructions 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaTextureArray 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaGlobals 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLexer
INFO     Test completed in 0.0309610366821 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestLexer

Description: Tests for the PTX lexer. Test Point 1: Scan a PTX file and 
             write out a temp stream, scan the stream again and make sure that the 
             two sets of tokens match


Test Seed : 1305582754
Test time : 1.3113e-05

Status : 


INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestConvergence 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCalVectorScale
INFO     Test completed in 0.0295689105988 seconds
INFO      It produced the following output:
No CAL devices found
Pass/Fail : Pass

INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestParser -i ../tests/ptx 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestPTXToLLVMTranslator
INFO     Test completed in 0.0324609279633 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestPTXToLLVMTranslator

Description: This is a basic test that just tries to get through a 
             translation successfully of as many PTX programs as possible Test 
             Points: 1) Scan for all PTX files in a directory, try to 
             translate them.


Test Seed : 1305582754
Test time : 1.04904e-05

Status : 


INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestDataflowGraph -i ../tests/ptx 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestInstructions
INFO     Test completed in 0.033910036087 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestInstructions

Description: 


Test Seed : 1305582754
Test time : 0.000641823

Status : Test output:
Accessors test passed.
pass: load and store instructions
Abs test passed.
pass: arithmetic instructions
pass: exotic arithmetic instructions
pass: floating-point instructions
pass: logical instructions
pass: comparison instructions
pass: predicated Add and Ld isntructions
pass: control flow instructions



INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestFunctionCall 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaTexture2D
INFO     Test completed in 0.0382449626923 seconds
INFO      It produced the following output:
(0.002894) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel '_Z6kernelPfii'.
(0.002920) LLVMDynamicTranslationCache.cpp:145:  LLVMDynamicTranslationCache::loadModule() - texture2D.cu
(0.002933) KernelPartitioningPass.cpp:593:  Run on kernel '_Z6kernelPfii'
/*
* Ocelot Version : 2.0.896
*/
.entry _Z6kernelPfii(.param  .u64 __cudaparm__Z6kernelPfii_out,
		.param  .s32 __cudaparm__Z6kernelPfii_width,
		.param  .s32 __cudaparm__Z6kernelPfii_height)
{

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .u32 %r9;
	.reg .f32 %r10;
	.reg .f32 %r11;
	.reg .f32 %r12;
	.reg .f32 %r13;
	.reg .f32 %r14;
	.reg .f32 %r15;
	.reg .f32 %r16;
	.reg .f32 %r17;
	.reg .f32 %r18;
	.reg .u64 %r19;
	.reg .u32 %r20;
	.reg .u32 %r21;
	.reg .u32 %r22;
	.reg .u64 %r23;
	.reg .u64 %r24;
	.reg .u64 %r25;
	$BB_1_0002:				/* $LDWbegin__Z6kernelPfii */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %ctaid.y;
		mov.u32 %r4, %ntid.y;
		mul.lo.u32 %r5, %r3, %r4;
		mov.u32 %r6, %tid.x;
		add.u32 %r7, %r6, %r2;
		mov.u32 %r8, %tid.y;
		add.u32 %r9, %r8, %r5;
		cvt.rn.f32.u32 %r10, %r7;
		cvt.rn.f32.u32 %r11, %r9;
		mov.f32 %r12, 0f00000000;
		mov.f32 %r13, 0f00000000;
		tex.2d.v4.f32.f32 {%r14, %r15, %r16, %r17}, [Surface, {%r10, %r11, %r12, %r13}];
		mov.f32 %r18, %r14;
		ld.param.u64 %r19, [__cudaparm__Z6kernelPfii_out];
		ld.param.u32 %r20, [__cudaparm__Z6kernelPfii_width];
		mul.lo.u32 %r21, %r20, %r9;
		add.u32 %r22, %r7, %r21;
		cvt.u64.u32 %r23, %r22;
		mul.wide.u32 %r24, %r22, 4;
		add.u64 %r25, %r19, %r24;
		st.global.f32 [%r25 + 0], %r18;
		exit;
}
(0.003211) KernelPartitioningPass.cpp:596:  


(0.003439) KernelPartitioningPass.cpp:145:    Spill region size is 200
(0.003450) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.003458) KernelPartitioningPass.cpp:159:   block entry
(0.003466) KernelPartitioningPass.cpp:159:   block exit
(0.003473) KernelPartitioningPass.cpp:159:   block $BB_1_0002
(0.003711) KernelPartitioningPass.cpp:185:  identifying transition points
(0.003727) KernelPartitioningPass.cpp:199:   block $BB_1_0002
(0.003742) KernelPartitioningPass.cpp:229:   block $BB_1_0002
(0.003760) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.003769) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.003783) KernelPartitioningPass.cpp:549:  created exit in block '$BB_1_0002_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry _Z6kernelPfii(.param  .u64 __cudaparm__Z6kernelPfii_out,
		.param  .s32 __cudaparm__Z6kernelPfii_width,
		.param  .s32 __cudaparm__Z6kernelPfii_height)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[200];

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .u32 %r9;
	.reg .f32 %r10;
	.reg .f32 %r11;
	.reg .f32 %r12;
	.reg .f32 %r13;
	.reg .f32 %r14;
	.reg .f32 %r15;
	.reg .f32 %r16;
	.reg .f32 %r17;
	.reg .f32 %r18;
	.reg .u64 %r19;
	.reg .u32 %r20;
	.reg .u32 %r21;
	.reg .u32 %r22;
	.reg .u64 %r23;
	.reg .u64 %r24;
	.reg .u64 %r25;
	.reg .u32 %r26;
	$BB_1_0002:				/* $LDWbegin__Z6kernelPfii */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %ctaid.y;
		mov.u32 %r4, %ntid.y;
		mul.lo.u32 %r5, %r3, %r4;
		mov.u32 %r6, %tid.x;
		add.u32 %r7, %r6, %r2;
		mov.u32 %r8, %tid.y;
		add.u32 %r9, %r8, %r5;
		cvt.rn.f32.u32 %r10, %r7;
		cvt.rn.f32.u32 %r11, %r9;
		mov.f32 %r12, 0f00000000;
		mov.f32 %r13, 0f00000000;
		tex.2d.v4.f32.f32 {%r14, %r15, %r16, %r17}, [Surface, {%r10, %r11, %r12, %r13}];
		mov.f32 %r18, %r14;
		ld.param.u64 %r19, [__cudaparm__Z6kernelPfii_out];
		ld.param.u32 %r20, [__cudaparm__Z6kernelPfii_width];
		mul.lo.u32 %r21, %r20, %r9;
		add.u32 %r22, %r7, %r21;
		cvt.u64.u32 %r23, %r22;
		mul.wide.u32 %r24, %r22, 4;
		add.u64 %r25, %r19, %r24;
		st.global.f32 [%r25 + 0], %r18;
		bra $BB_1_0002_exit;
	$BB_1_0002_entry:				/* entryId: 0 */ 
		bra $BB_1_0002;
	$BB_1_0002_exit:				/* exit */ 
		mov.u32 %r26, _Zocelot_resume_status;
		st.local.u32 [%r26 + 0], 6;
		yield;
}
(0.004368) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 4, 4
(0.004379) LLVMDynamicExecutionManager.cpp:61:     block dim: 16, 16, 1
(0.004388) LLVMDynamicExecutionManager.cpp:62:     entry id: 0
(0.004396) LLVMDynamicExecutionManager.cpp:63:     local memory size: 208 bytes
(0.004405) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 0 bytes 
(0.004416) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.004424) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.004436) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 208, total threads: 256, shared memory size: 0
(0.004511) LLVMDynamicExecutive.cpp:207:  execute()
(0.004525) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 0
(0.004534) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.004545) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 0
(0.004554) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 0, ws: 2)
(0.004562) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.004570) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 0, warpsize: 2)
(0.004579) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager
(0.006204) LLVMDynamicTranslationCache.cpp:1037: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type {While deleting: void (float*, { { i32, i32, i32 }, { i32, i32, i32 }, { i32, i32, i32 }, { i32, i32, i32 }, i8*, i8*, i8*, i8*, i8*, i8* }*, i32, float, float)* %__ocelot_tex_2d_ff
Use still stuck around after Def is destroyed:  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r10, float %r11)
TestCudaTexture2D: Value.cpp:76: virtual llvm::Value::~Value(): Assertion `use_empty() && "Uses remain when a value is destroyed!"' failed.
 i32, i32, i32 };
define default void @_Z_ocelotTranslated__Z6kernelPfii( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$OcelotTextureAllocateBlock:
	%integerTexture = alloca i32, i32 4, align 16;
	%floatingPointTexture = alloca float, i32 4, align 16;
	br label %$BB_1_0002;
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0;
	%rt3 = load i32* %rt2;
	%r1 = bitcast i32 %rt3 to i32;
	%r2 = mul i32 %r0, %r1;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1;
	%rt5 = load i32* %rt4;
	%r3 = bitcast i32 %rt5 to i32;
	%rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1;
	%rt7 = load i32* %rt6;
	%r4 = bitcast i32 %rt7 to i32;
	%r5 = mul i32 %r3, %r4;
	%rt8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt9 = load i32* %rt8;
	%r6 = bitcast i32 %rt9 to i32;
	%r7 = add i32 %r6, %r2;
	%rt10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1;
	%rt11 = load i32* %rt10;
	%r8 = bitcast i32 %rt11 to i32;
	%r9 = add i32 %r8, %r5;
	%r10 = uitofp i32 %r7 to float;
	%r11 = uitofp i32 %r9 to float;
	%r12 = bitcast float 0x0 to float;
	%r13 = bitcast float 0x0 to float;
	call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r10, float %r11);
	%r14 = load float* %floatingPointTexture;
	%rt12 = getelementptr float* %floatingPointTexture, i32 1;
	%r15 = load float* %rt12;
	%rt13 = getelementptr float* %floatingPointTexture, i32 2;
	%r16 = load float* %rt13;
	%rt14 = getelementptr float* %floatingPointTexture, i32 3;
	%r17 = load float* %rt14;
	%r18 = bitcast float %r14 to float;
	%rt15 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt16 = load i8** %rt15;
	%rt17 = bitcast i8* %rt16 to i64*;
	%r19 = load i64* %rt17, align 8;
	%rt19 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt20 = load i8** %rt19;
	%rt18 = getelementptr i8* %rt20, i32 8;
	%rt21 = bitcast i8* %rt18 to i32*;
	%r20 = load i32* %rt21, align 4;
	%r21 = mul i32 %r20, %r9;
	%r22 = add i32 %r7, %r21;
	%r23 = zext i32 %r22 to i64;
	%rt22 = zext i32 %r22 to i64;
	%r24 = mul i64 %rt22, 4;
	%r25 = add i64 %r19, %r24;
	%rt23 = inttoptr i64 %r25 to float*;
	store float %r18, float* %rt23, align 4;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r26 = bitcast i32 0 to i32;
	%rt24 = zext i32 %r26 to i64;
	%rt25 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt26 = load i8** %rt25;
	%rt27 = ptrtoint i8* %rt26 to i64;
	%rt28 = add i64 %rt24, %rt27;
	%rt29 = inttoptr i64 %rt28 to i32*;
	store i32 6, i32* %rt29, align 4;
	br label %exit;
exit:
	ret void;

}


INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaSequence 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaTextureArray
INFO     Test completed in 0.0349519252777 seconds
INFO      It produced the following output:
(0.002207) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel '_Z6kernelPfii'.
(0.002235) LLVMDynamicTranslationCache.cpp:145:  LLVMDynamicTranslationCache::loadModule() - textureArray.cu
(0.002248) KernelPartitioningPass.cpp:593:  Run on kernel '_Z6kernelPfii'
/*
* Ocelot Version : 2.0.896
*/
.entry _Z6kernelPfii(.param  .u64 __cudaparm__Z6kernelPfii_out,
		.param  .s32 __cudaparm__Z6kernelPfii_width,
		.param  .s32 __cudaparm__Z6kernelPfii_height)
{

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .u32 %r9;
	.reg .f32 %r10;
	.reg .f32 %r11;
	.reg .f32 %r12;
	.reg .f32 %r13;
	.reg .f32 %r14;
	.reg .f32 %r15;
	.reg .f32 %r16;
	.reg .f32 %r17;
	.reg .f32 %r18;
	.reg .u64 %r19;
	.reg .u32 %r20;
	.reg .u32 %r21;
	.reg .u32 %r22;
	.reg .u64 %r23;
	.reg .u64 %r24;
	.reg .u64 %r25;
	$BB_1_0002:				/* $LDWbegin__Z6kernelPfii */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %ctaid.y;
		mov.u32 %r4, %ntid.y;
		mul.lo.u32 %r5, %r3, %r4;
		mov.u32 %r6, %tid.x;
		add.u32 %r7, %r6, %r2;
		mov.u32 %r8, %tid.y;
		add.u32 %r9, %r8, %r5;
		cvt.rn.f32.u32 %r10, %r7;
		cvt.rn.f32.u32 %r11, %r9;
		mov.f32 %r12, 0f00000000;
		mov.f32 %r13, 0f00000000;
		tex.2d.v4.f32.f32 {%r14, %r15, %r16, %r17}, [Surface, {%r10, %r11, %r12, %r13}];
		mov.f32 %r18, %r14;
		ld.param.u64 %r19, [__cudaparm__Z6kernelPfii_out];
		ld.param.u32 %r20, [__cudaparm__Z6kernelPfii_width];
		mul.lo.u32 %r21, %r20, %r9;
		add.u32 %r22, %r7, %r21;
		cvt.u64.u32 %r23, %r22;
		mul.wide.u32 %r24, %r22, 4;
		add.u64 %r25, %r19, %r24;
		st.global.f32 [%r25 + 0], %r18;
		exit;
}
(0.002508) KernelPartitioningPass.cpp:596:  


(0.002644) KernelPartitioningPass.cpp:145:    Spill region size is 200
(0.002650) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.002655) KernelPartitioningPass.cpp:159:   block entry
(0.002660) KernelPartitioningPass.cpp:159:   block exit
(0.002664) KernelPartitioningPass.cpp:159:   block $BB_1_0002
(0.002789) KernelPartitioningPass.cpp:185:  identifying transition points
(0.002798) KernelPartitioningPass.cpp:199:   block $BB_1_0002
(0.002807) KernelPartitioningPass.cpp:229:   block $BB_1_0002
(0.002818) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.002824) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.002833) KernelPartitioningPass.cpp:549:  created exit in block '$BB_1_0002_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry _Z6kernelPfii(.param  .u64 __cudaparm__Z6kernelPfii_out,
		.param  .s32 __cudaparm__Z6kernelPfii_width,
		.param  .s32 __cudaparm__Z6kernelPfii_height)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[200];

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .u32 %r9;
	.reg .f32 %r10;
	.reg .f32 %r11;
	.reg .f32 %r12;
	.reg .f32 %r13;
	.reg .f32 %r14;
	.reg .f32 %r15;
	.reg .f32 %r16;
	.reg .f32 %r17;
	.reg .f32 %r18;
	.reg .u64 %r19;
	.reg .u32 %r20;
	.reg .u32 %r21;
	.reg .u32 %r22;
	.reg .u64 %r23;
	.reg .u64 %r24;
	.reg .u64 %r25;
	.reg .u32 %r26;
	$BB_1_0002:				/* $LDWbegin__Z6kernelPfii */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %ctaid.y;
		mov.u32 %r4, %ntid.y;
		mul.lo.u32 %r5, %r3, %r4;
		mov.u32 %r6, %tid.x;
		add.u32 %r7, %r6, %r2;
		mov.u32 %r8, %tid.y;
		add.u32 %r9, %r8, %r5;
		cvt.rn.f32.u32 %r10, %r7;
		cvt.rn.f32.u32 %r11, %r9;
		mov.f32 %r12, 0f00000000;
		mov.f32 %r13, 0f00000000;
		tex.2d.v4.f32.f32 {%r14, %r15, %r16, %r17}, [Surface, {%r10, %r11, %r12, %r13}];
		mov.f32 %r18, %r14;
		ld.param.u64 %r19, [__cudaparm__Z6kernelPfii_out];
		ld.param.u32 %r20, [__cudaparm__Z6kernelPfii_width];
		mul.lo.u32 %r21, %r20, %r9;
		add.u32 %r22, %r7, %r21;
		cvt.u64.u32 %r23, %r22;
		mul.wide.u32 %r24, %r22, 4;
		add.u64 %r25, %r19, %r24;
		st.global.f32 [%r25 + 0], %r18;
		bra $BB_1_0002_exit;
	$BB_1_0002_entry:				/* entryId: 0 */ 
		bra $BB_1_0002;
	$BB_1_0002_exit:				/* exit */ 
		mov.u32 %r26, _Zocelot_resume_status;
		st.local.u32 [%r26 + 0], 6;
		yield;
}
(0.003148) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 4, 4
(0.003154) LLVMDynamicExecutionManager.cpp:61:     block dim: 16, 16, 1
(0.003159) LLVMDynamicExecutionManager.cpp:62:     entry id: 0
(0.003163) LLVMDynamicExecutionManager.cpp:63:     local memory size: 208 bytes
(0.003168) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 0 bytes 
(0.003172) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.003179) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.003186) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 208, total threads: 256, shared memory size: 0
(0.003236) LLVMDynamicExecutive.cpp:207:  execute()
(0.003244) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 0
(0.003249) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.003255) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 0
(0.003260) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 0, ws: 2)
(0.003265) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.003270) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 0, warpsize: 2)
(0.003274) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager
(0.004244) LLVMDynamicTranslationCache.cpp:1037: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = typWhile deleting: void (float*, { { i32, i32, i32 }, { i32, i32, i32 }, { i32, i32, i32 }, { i32, i32, i32 }, i8*, i8*, i8*, i8*, i8*, i8* }*, i32, float, float)* %__ocelot_tex_2d_ff
Use still stuck around after Def is destroyed:  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r10, float %r11)
TestCudaTextureArray: Value.cpp:76: virtual llvm::Value::~Value(): Assertion `use_empty() && "Uses remain when a value is destroyed!"' failed.
e { i32, i32, i32 };
define default void @_Z_ocelotTranslated__Z6kernelPfii( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$OcelotTextureAllocateBlock:
	%integerTexture = alloca i32, i32 4, align 16;
	%floatingPointTexture = alloca float, i32 4, align 16;
	br label %$BB_1_0002;
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0;
	%rt3 = load i32* %rt2;
	%r1 = bitcast i32 %rt3 to i32;
	%r2 = mul i32 %r0, %r1;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1;
	%rt5 = load i32* %rt4;
	%r3 = bitcast i32 %rt5 to i32;
	%rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1;
	%rt7 = load i32* %rt6;
	%r4 = bitcast i32 %rt7 to i32;
	%r5 = mul i32 %r3, %r4;
	%rt8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt9 = load i32* %rt8;
	%r6 = bitcast i32 %rt9 to i32;
	%r7 = add i32 %r6, %r2;
	%rt10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1;
	%rt11 = load i32* %rt10;
	%r8 = bitcast i32 %rt11 to i32;
	%r9 = add i32 %r8, %r5;
	%r10 = uitofp i32 %r7 to float;
	%r11 = uitofp i32 %r9 to float;
	%r12 = bitcast float 0x0 to float;
	%r13 = bitcast float 0x0 to float;
	call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r10, float %r11);
	%r14 = load float* %floatingPointTexture;
	%rt12 = getelementptr float* %floatingPointTexture, i32 1;
	%r15 = load float* %rt12;
	%rt13 = getelementptr float* %floatingPointTexture, i32 2;
	%r16 = load float* %rt13;
	%rt14 = getelementptr float* %floatingPointTexture, i32 3;
	%r17 = load float* %rt14;
	%r18 = bitcast float %r14 to float;
	%rt15 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt16 = load i8** %rt15;
	%rt17 = bitcast i8* %rt16 to i64*;
	%r19 = load i64* %rt17, align 8;
	%rt19 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt20 = load i8** %rt19;
	%rt18 = getelementptr i8* %rt20, i32 8;
	%rt21 = bitcast i8* %rt18 to i32*;
	%r20 = load i32* %rt21, align 4;
	%r21 = mul i32 %r20, %r9;
	%r22 = add i32 %r7, %r21;
	%r23 = zext i32 %r22 to i64;
	%rt22 = zext i32 %r22 to i64;
	%r24 = mul i64 %rt22, 4;
	%r25 = add i64 %r19, %r24;
	%rt23 = inttoptr i64 %r25 to float*;
	store float %r18, float* %rt23, align 4;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r26 = bitcast i32 0 to i32;
	%rt24 = zext i32 %r26 to i64;
	%rt25 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt26 = load i8** %rt25;
	%rt27 = ptrtoint i8* %rt26 to i64;
	%rt28 = add i64 %rt24, %rt27;
	%rt29 = inttoptr i64 %rt28 to i32*;
	store i32 6, i32* %rt29, align 4;
	br label %exit;
exit:
	ret void;

}


INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestKernels
INFO     Test completed in 0.0464010238647 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestKernels

Description: 


Test Seed : 1305582754
Test time : 0.0110009

Status : Test output:
looping kernel succeeded
matrix vector kernel succeeded



INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLLVMInstructions 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestDeviceSwitching 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaGlobals
INFO     Test completed in 0.0419881343842 seconds
INFO      It produced the following output:
cudaSetDevice() - 0 - Ocelot Dynamic Multicore CPU Backend (LLVM-JIT) 
(0.003025) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel 'copyFromGlobal'.
(0.003046) LLVMDynamicTranslationCache.cpp:145:  LLVMDynamicTranslationCache::loadModule() - global.cu
(0.003059) KernelPartitioningPass.cpp:593:  Run on kernel 'copyFromGlobal'
/*
* Ocelot Version : 2.0.896
*/
.entry copyFromGlobal(.param  .u64 __cudaparm_copyFromGlobal_result)
{

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .u32 %r9;
	.reg .u32 %r10;
	.reg .u32 %r11;
	.reg .f32 %r12;
	.reg .f32 %r13;
	.reg .f32 %r14;
	.reg .u64 %r15;
	.reg .u64 %r16;
	.reg .u64 %r17;
	.reg .u64 %r18;
	$BB_1_0002:				/* $LDWbegin_copyFromGlobal */ 
		mov.u32 %r0, %tid.x;
		mov.u32 %r1, %ctaid.x;
		mov.u32 %r2, %ntid.x;
		mul.lo.u32 %r3, %r1, %r2;
		add.u32 %r4, %r0, %r3;
		shr.s32 %r5, %r4, 31;
		mov.s32 %r6, 127;
		and.b32 %r7, %r5, %r6;
		add.s32 %r8, %r7, %r4;
		shr.s32 %r9, %r8, 7;
		mul.lo.s32 %r10, %r9, 128;
		sub.s32 %r11, %r4, %r10;
		cvt.rn.f32.s32 %r12, %r11;
		ld.global.f32 %r13, [Pi];
		mul.f32 %r14, %r12, %r13;
		ld.param.u64 %r15, [__cudaparm_copyFromGlobal_result];
		cvt.s64.s32 %r16, %r4;
		mul.wide.s32 %r17, %r4, 4;
		add.u64 %r18, %r15, %r17;
		st.global.f32 [%r18 + 0], %r14;
		exit;
}
(0.003289) KernelPartitioningPass.cpp:596:  


(0.003493) KernelPartitioningPass.cpp:145:    Spill region size is 144
(0.003504) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.003512) KernelPartitioningPass.cpp:159:   block entry
(0.003521) KernelPartitioningPass.cpp:159:   block exit
(0.003529) KernelPartitioningPass.cpp:159:   block $BB_1_0002
(0.003783) KernelPartitioningPass.cpp:185:  identifying transition points
(0.003798) KernelPartitioningPass.cpp:199:   block $BB_1_0002
(0.003814) KernelPartitioningPass.cpp:229:   block $BB_1_0002
(0.003832) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.003844) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.003866) KernelPartitioningPass.cpp:549:  created exit in block '$BB_1_0002_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry copyFromGlobal(.param  .u64 __cudaparm_copyFromGlobal_result)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[144];

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .u32 %r9;
	.reg .u32 %r10;
	.reg .u32 %r11;
	.reg .f32 %r12;
	.reg .f32 %r13;
	.reg .f32 %r14;
	.reg .u64 %r15;
	.reg .u64 %r16;
	.reg .u64 %r17;
	.reg .u64 %r18;
	.reg .u32 %r19;
	$BB_1_0002:				/* $LDWbegin_copyFromGlobal */ 
		mov.u32 %r0, %tid.x;
		mov.u32 %r1, %ctaid.x;
		mov.u32 %r2, %ntid.x;
		mul.lo.u32 %r3, %r1, %r2;
		add.u32 %r4, %r0, %r3;
		shr.s32 %r5, %r4, 31;
		mov.s32 %r6, 127;
		and.b32 %r7, %r5, %r6;
		add.s32 %r8, %r7, %r4;
		shr.s32 %r9, %r8, 7;
		mul.lo.s32 %r10, %r9, 128;
		sub.s32 %r11, %r4, %r10;
		cvt.rn.f32.s32 %r12, %r11;
		ld.global.f32 %r13, [Pi];
		mul.f32 %r14, %r12, %r13;
		ld.param.u64 %r15, [__cudaparm_copyFromGlobal_result];
		cvt.s64.s32 %r16, %r4;
		mul.wide.s32 %r17, %r4, 4;
		add.u64 %r18, %r15, %r17;
		st.global.f32 [%r18 + 0], %r14;
		bra $BB_1_0002_exit;
	$BB_1_0002_entry:				/* entryId: 0 */ 
		bra $BB_1_0002;
	$BB_1_0002_exit:				/* exit */ 
		mov.u32 %r19, _Zocelot_resume_status;
		st.local.u32 [%r19 + 0], 6;
		yield;
}
(0.004302) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 1, 1
(0.004311) LLVMDynamicExecutionManager.cpp:61:     block dim: 64, 1, 1
(0.004318) LLVMDynamicExecutionManager.cpp:62:     entry id: 0
(0.004325) LLVMDynamicExecutionManager.cpp:63:     local memory size: 152 bytes
(0.004332) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 0 bytes 
(0.004340) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.004347) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.004358) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 152, total threads: 64, shared memory size: 0
(0.004409) LLVMDynamicExecutive.cpp:207:  execute()
(0.004422) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 0
(0.004431) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.004441) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 0
(0.004450) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 0, ws: 2)
(0.004459) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.004467) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 0, warpsize: 2)
(0.004475) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager
(0.005923) LLVMDynamicTranslationCache.cpp:1037: ; Code assembled by Ocelot LLVMKernel 2.0.896

@Pi = external global float, align 4;

%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_copyFromGlobal( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0;
	%rt3 = load i32* %rt2;
	%r1 = bitcast i32 %rt3 to i32;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0;
	%rt5 = load i32* %rt4;
	%r2 = bitcast i32 %rt5 to i32;
	%r3 = mul i32 %r1, %r2;
	%r4 = add i32 %r0, %r3;
	%r5 = ashr i32 %r4, 31;
	%r6 = bitcast i32 127 to i32;
	%r7 = and i32 %r5, %r6;
	%r8 = add i32 %r7, %r4;
	%r9 = ashr i32 %r8, 
define internal void @_Z_ocelotTranslated_copyFromGlobal_opt3_ws2(%LLVMContext* %__ctaContext) nounwind align 1 {
WarpSynchronousEntry:
  %ptrLocalMemPtr = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 4
  %localMemPtr.0 = load i8** %ptrLocalMemPtr, align 8
  %ptr = getelementptr i8* %localMemPtr.0, i64 4
  %ptrEntryPoint = bitcast i8* %ptr to i32*
  %warpEntryId = load i32* %ptrEntryPoint, align 4
  %warpEntryPoint = and i32 %warpEntryId, 65535
  %rt0.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 0, i32 0
  %rt0.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 0, i32 0
  %rt1.t0 = load i32* %rt0.t0, align 4
  %rt1.t1 = load i32* %rt0.t1, align 4
  %rt2.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 2, i32 0
  %rt2.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 2, i32 0
  %rt3.t0 = load i32* %rt2.t0, align 4
  %rt3.t1 = load i32* %rt2.t1, align 4
  %rt4.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 1, i32 0
  %rt4.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 1, i32 0
  %rt5.t0 = load i32* %rt4.t0, align 4
  %rt5.t1 = load i32* %rt4.t1, align 4
  %r3.t0 = mul i32 %rt5.t0, %rt3.t0
  %r3.t1 = mul i32 %rt5.t1, %rt3.t1
  %r4.t0 = add i32 %r3.t0, %rt1.t0
  %r4.t1 = add i32 %r3.t1, %rt1.t1
  %r5.t0 = ashr i32 %r4.t0, 31
  %r5.t1 = ashr i32 %r4.t1, 31
  %r7.t0 = and i32 %r5.t0, 127
  %r7.t1 = and i32 %r5.t1, 127
  %r8.t0 = add i32 %r7.t0, %r4.t0
  %r8.t1 = add i32 %r7.t1, %r4.t1
  %r9.t05 = and i32 %r8.t0, -128
  %r9.t16 = and i32 %r8.t1, -128
  %r11.t0 = sub i32 %r4.t0, %r9.t05
  %r11.t1 = sub i32 %r4.t1, %r9.t16
  %r12.t0 = sitofp i32 %r11.t0 to float
  %r12.t1 = sitofp i32 %r11.t1 to float
  %0 = insertelement <2 x float> undef, float %r12.t0, i32 0
  %1 = insertelement <2 x float> %0, float %r12.t1, i32 1
  %r13.t0 = load float* @Pi, align 4
  %2 = insertelement <2 x float> undef, float %r13.t0, i32 0
  %3 = insertelement <2 x float> %2, float %r13.t0, i32 1
  %4 = fmul <2 x float> %1, %3
  %5 = extractelement <2 x float> %4, i32 0
  %6 = extractelement <2 x float> %4, i32 1
  %rt7.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 8
  %rt7.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 8
  %rt8.t0 = load i8** %rt7.t0, align 8
  %rt8.t1 = load i8** %rt7.t1, align 8
  %rt9.t0 = bitcast i8* %rt8.t0 to i64*
  %rt9.t1 = bitcast i8* %rt8.t1 to i64*
  %r15.t0 = load i64* %rt9.t0, align 8
  %r15.t1 = load i64* %rt9.t1, align 8
  %rt10.t0 = sext i32 %r4.t0 to i64
  %rt10.t1 = sext i32 %r4.t1 to i64
  %r17.t0 = mul i64 %rt10.t0, 4
  %r17.t1 = mul i64 %rt10.t1, 4
  %r18.t0 = add i64 %r15.t0, %r17.t0
  %r18.t1 = add i64 %r15.t1, %r17.t1
  %rt11.t0 = inttoptr i64 %r18.t0 to float*
  %rt11.t1 = inttoptr i64 %r18.t1 to float*
  store float %5, float* %rt11.t0, align 4
  store float %6, float* %rt11.t1, align 4
  %rt13.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 4
  %rt14.t0 = load i8** %ptrLocalMemPtr, align 8
  %rt14.t1 = load i8** %rt13.t1, align 8
  %rt17.t0 = bitcast i8* %rt14.t0 to i32*
  %rt17.t1 = bitcast i8* %rt14.t1 to i32*
  store i32 6, i32* %rt17.t0, align 4
  store i32 6, i32* %rt17.t1, align 4
  ret void
}

LLVM ERROR: Could not resolve external global address: Pi
TestCudaGlobals: /usr/include/boost/thread/pthread/mutex.hpp:45: boost::mutex::~mutex(): Assertion `!pthread_mutex_destroy(&m)' failed.
7;
	%r10 = mul i32 %r9, 128;
	%r11 = sub i32 %r4, %r10;
	%r12 = sitofp i32 %r11 to float;
	%rt6 = bitcast float* @Pi to float*;
	%r13 = load float* %rt6, align 4;
	%r14 = fmul float %r12, %r13;
	%rt7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt8 = load i8** %rt7;
	%rt9 = bitcast i8* %rt8 to i64*;
	%r15 = load i64* %rt9, align 8;
	%r16 = sext i32 %r4 to i64;
	%rt10 = sext i32 %r4 to i64;
	%r17 = mul i64 %rt10, 4;
	%r18 = add i64 %r15, %r17;
	%rt11 = inttoptr i64 %r18 to float*;
	store float %r14, float* %rt11, align 4;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r19 = bitcast i32 0 to i32;
	%rt12 = zext i32 %r19 to i64;
	%rt13 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt14 = load i8** %rt13;
	%rt15 = ptrtoint i8* %rt14 to i64;
	%rt16 = add i64 %rt12, %rt15;
	%rt17 = inttoptr i64 %rt16 to i32*;
	store i32 6, i32* %rt17, align 4;
	br label %exit;
exit:
	ret void;

}

(0.008754) LLVMUniformVectorization.cpp:222:  Vectorization: _Z_ocelotTranslated_copyFromGlobal_opt3_ws2
(0.008770) LLVMUniformVectorization.cpp:226:  Breadth first traversal:
(0.008787) LLVMUniformVectorization.cpp:229:  Creating prolog block to replace scheduler
(0.008800) LLVMUniformVectorization.cpp:232:  Loading thread-local values
(0.008809) LLVMUniformVectorization.cpp:383:  loadThreadLocalArguments
(0.008881) LLVMUniformVectorization.cpp:239:  Adding interleaved and replicated instructions:
(0.008895) LLVMUniformVectorization.cpp:449:  AddInterleavedInstructions()
(0.008903) LLVMUniformVectorization.cpp:454:    traversal contains:
(0.008912) LLVMUniformVectorization.cpp:459:    - $BB_1_0002
(0.008926) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_ws_2]
(0.008938) LLVMUniformVectorization.cpp:459:    - $BB_1_0002_exit
(0.008950) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_exit_ws_2]
(0.008960) LLVMUniformVectorization.cpp:459:    - exit
(0.008972) LLVMUniformVectorization.cpp:472:      [ constructed as exit_ws_2]
(0.008982) LLVMUniformVectorization.cpp:459:    - $BB_1_0002_entry
(0.008994) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_entry_ws_2]
(0.009349) LLVMUniformVectorization.cpp:242:  Updating data dependencies among replicated instructions
(0.009376) LLVMUniformVectorization.cpp:245:  Updating control flow among warp-synchronous replicated blocks
(0.009391) LLVMUniformVectorization.cpp:248:  Vectorizing replicated instruction bundles
(0.009460) LLVMUniformVectorization.cpp:255:  Removing superfluous scalar blocks
(0.009492) LLVMUniformVectorization.cpp:258:  Creating scheduler block
(0.009503) LLVMUniformVectorization.cpp:1373: Updating subkernel entry points
(0.009521) LLVMUniformVectorization.cpp:1399: There are 1 entry points
(0.009532) LLVMUniformVectorization.cpp:1344: seeking label BB_1_0002_entry_ws
(0.009542) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.009551) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_ws_2
(0.009560) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_exit_ws_2
(0.009568) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.009578) LLVMUniformVectorization.cpp:1414: Created switch with 1 cases
(0.009588) LLVMUniformVectorization.cpp:1421: adding successor 0 - $BB_1_0002_entry_ws_2
(0.009597) LLVMUniformVectorization.cpp:1424: Created large switch statement in scheduler
(0.009606) LLVMUniformVectorization.cpp:261:  Finalizing subkernel
(0.009614) LLVMUniformVectorization.cpp:265:  end vectorization _Z_ocelotTranslated_copyFromGlobal_opt3_ws2

(0.012555) LLVMDynamicTranslationCache.cpp:1215: performed transformations
pure virtual method called
terminate called without an active exception

INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestParser
INFO     Test completed in 0.026046037674 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestParser

Description: A test for the PTXParser class. Test Points: 1) Load a PTX file 
             and run it through the parser generating a module. Write the 
             module to an intermediate stream. Parse the stream again 
             generating a new module, compare both to make sure that they match.


Test Seed : 1305582754
Test time : 1.54972e-05

Status : 


INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestDataflowGraph
INFO     Test completed in 0.0253558158875 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestDataflowGraph

Description: A test for the DataflowGraph class. Test Points: 1) 
             Generic: load PTX files, convert them into dataflow graphs, verify that 
             all live ranges spanning blocks are consistent. 2) SSA: convert to 
             ssa form, verify that no register is declared more than once. 3) 
             reverse SSA: convert to ssa then out of ssa, verify that all live 
             ranges spanning blocks are consistent.


Test Seed : 1305582754
Test time : 2.26498e-05

Status : Testing Generic Dataflow
 Test Passed
Testing SSA Dataflow
 Test Passed
Testing SSA then back Dataflow
 Test Passed



INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestPTXAssembly 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLLVMKernels 
INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestEmulator 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestConvergence
INFO     Test completed in 0.0385510921478 seconds
INFO      It produced the following output:
(0.002675) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel 'convergence'.
(0.002704) LLVMDynamicTranslationCache.cpp:145:  LLVMDynamicTranslationCache::loadModule() - TestConvergence.cu
(0.002719) KernelPartitioningPass.cpp:593:  Run on kernel 'convergence'
/*
* Ocelot Version : 2.0.896
*/
.entry convergence(.param  .u64 __cudaparm_convergence_A)
{

	.reg .u32 %r0;
	.reg .f32 %r1;
	.reg .f32 %r2;
	.reg .f32 %r3;
	.reg .f32 %r4;
	.reg .u64 %r5;
	.reg .u64 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	$BB_1_0002:				/* $LDWbegin_convergence */ 
		cvt.s32.u32 %r0, %tid.x;
		cvt.rn.f32.s32 %r1, %r0;
		add.f32 %r2, %r1, %r1;
		mov.f32 %r3, 0f3f800000;
		add.f32 %r4, %r2, %r3;
		ld.param.u64 %r5, [__cudaparm_convergence_A];
		cvt.s64.s32 %r6, %r0;
		mul.wide.s32 %r7, %r0, 4;
		add.u64 %r8, %r5, %r7;
		st.global.f32 [%r8 + 0], %r4;
		exit;
}
(0.002862) KernelPartitioningPass.cpp:596:  


(0.002987) KernelPartitioningPass.cpp:145:    Spill region size is 64
(0.002998) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.003006) KernelPartitioningPass.cpp:159:   block entry
(0.003014) KernelPartitioningPass.cpp:159:   block exit
(0.003022) KernelPartitioningPass.cpp:159:   block $BB_1_0002
(0.003135) KernelPartitioningPass.cpp:185:  identifying transition points
(0.003161) KernelPartitioningPass.cpp:199:   block $BB_1_0002
(0.003178) KernelPartitioningPass.cpp:229:   block $BB_1_0002
(0.003197) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.003207) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.003222) KernelPartitioningPass.cpp:549:  created exit in block '$BB_1_0002_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry convergence(.param  .u64 __cudaparm_convergence_A)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[64];

	.reg .u32 %r0;
	.reg .f32 %r1;
	.reg .f32 %r2;
	.reg .f32 %r3;
	.reg .f32 %r4;
	.reg .u64 %r5;
	.reg .u64 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	.reg .u32 %r9;
	$BB_1_0002:				/* $LDWbegin_convergence */ 
		cvt.s32.u32 %r0, %tid.x;
		cvt.rn.f32.s32 %r1, %r0;
		add.f32 %r2, %r1, %r1;
		mov.f32 %r3, 0f3f800000;
		add.f32 %r4, %r2, %r3;
		ld.param.u64 %r5, [__cudaparm_convergence_A];
		cvt.s64.s32 %r6, %r0;
		mul.wide.s32 %r7, %r0, 4;
		add.u64 %r8, %r5, %r7;
		st.global.f32 [%r8 + 0], %r4;
		bra $BB_1_0002_exit;
	$BB_1_0002_entry:				/* entryId: 0 */ 
		bra $BB_1_0002;
	$BB_1_0002_exit:				/* exit */ 
		mov.u32 %r9, _Zocelot_resume_status;
		st.local.u32 [%r9 + 0], 6;
		yield;
}
(0.003528) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 1, 1
(0.003539) LLVMDynamicExecutionManager.cpp:61:     block dim: 4, 1, 1
(0.003548) LLVMDynamicExecutionManager.cpp:62:     entry id: 0
(0.003556) LLVMDynamicExecutionManager.cpp:63:     local memory size: 72 bytes
(0.003565) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 0 bytes 
(0.003573) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.003583) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.003596) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 72, total threads: 4, shared memory size: 0
(0.003609) LLVMDynamicExecutive.cpp:207:  execute()
(0.003619) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 0
(0.003628) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.003638) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 0
(0.003646) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 0, ws: 2)
(0.003656) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.003664) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 0, warpsize: 2)
(0.003672) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager
(0.004939) LLVMDynamicTranslationCache.cpp:1037: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_convergence( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%r1 = sitofp i32 %r0 to float;
	%r2 = fadd float %r1, %r1;
	%r3 = bitcast float 0x3ff0000000000000 to float;
	%r4 = fadd float %r2, %r3;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt3 = load i8** %rt2;
	%rt4 = bitcast i8* %rt3 to i64*;
	%r5 = load i64* %rt4, align 8;
	%r6 = sext i32 %r0 to i64;
	%rt5 = sext i32 %r0 to i64;
	%r7 = mul i64 %rt5, 4;
	%r8 = add i64 %r5, %r7;
	%rt6 = inttoptr i64 %r8 to float*;
	store float %r4, float* %rt6, align 4;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r9 = bitcast i32 0 to i32;
	%rt7 = zext i32 %r9 to i64;
	%rt8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt9 = load i8** %rt8;
	%rt10 = ptrtoint i8* %rt9 to i64;
	%rt11 = add i64 %rt7, %rt10;
	%rt12 = inttoptr i64 %rt11 to i32*;
	store i32 6, i32* %rt12, align 4;
	br label %exit;
exit:
	ret void;

}

(0.007866) LLVMUniformVectorization.cpp:222:  Vectorization: _Z_ocelotTranslated_convergence_opt3_ws2
(0.007883) LLVMUniformVectorization.cpp:226:  Breadth first traversal:
(0.007898) LLVMUniformVectorization.cpp:229:  Creating prolog block to replace scheduler
(0.007910) LLVMUniformVectorization.cpp:232:  Loading thread-local values
(0.007919) LLVMUniformVectorization.cpp:383:  loadThreadLocalArguments
(0.007987) LLVMUniformVectorization.cpp:239:  Adding interleaved and replicated instructions:
(0.007997) LLVMUniformVectorization.cpp:449:  AddI
define internal void @_Z_ocelotTranslated_convergence_opt3_ws2(%LLVMContext* %__ctaContext) nounwind align 1 {
WarpSynchronousEntry:
  %ptrLocalMemPtr = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 4
  %localMemPtr.0 = load i8** %ptrLocalMemPtr, align 8
  %ptr = getelementptr i8* %localMemPtr.0, i64 4
  %ptrEntryPoint = bitcast i8* %ptr to i32*
  %warpEntryId = load i32* %ptrEntryPoint, align 4
  %warpEntryPoint = and i32 %warpEntryId, 65535
  %rt0.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 0, i32 0
  %rt0.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 0, i32 0
  %rt1.t0 = load i32* %rt0.t0, align 4
  %rt1.t1 = load i32* %rt0.t1, align 4
  %r1.t0 = sitofp i32 %rt1.t0 to float
  %r1.t1 = sitofp i32 %rt1.t1 to float
  %0 = insertelement <2 x float> undef, float %r1.t0, i32 0
  %1 = insertelement <2 x float> %0, float %r1.t1, i32 1
  %2 = fadd <2 x float> %1, %1
  %3 = fadd <2 x float> %2, <float 1.000000e+00, float 1.000000e+00>
  %4 = extractelement <2 x float> %3, i32 0
  %5 = extractelement <2 x float> %3, i32 1
  %rt2.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 8
  %rt2.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 8
  %rt3.t0 = load i8** %rt2.t0, align 8
  %rt3.t1 = load i8** %rt2.t1, align 8
  %rt4.t0 = bitcast i8* %rt3.t0 to i64*
  %rt4.t1 = bitcast i8* %rt3.t1 to i64*
  %r5.t0 = load i64* %rt4.t0, align 8
  %r5.t1 = load i64* %rt4.t1, align 8
  %rt5.t0 = sext i32 %rt1.t0 to i64
  %rt5.t1 = sext i32 %rt1.t1 to i64
  %r7.t0 = mul i64 %rt5.t0, 4
  %r7.t1 = mul i64 %rt5.t1, 4
  %r8.t0 = add i64 %r5.t0, %r7.t0
  %r8.t1 = add i64 %r5.t1, %r7.t1
  %rt6.t0 = inttoptr i64 %r8.t0 to float*
  %rt6.t1 = inttoptr i64 %r8.t1 to float*
  store float %4, float* %rt6.t0, align 4
  store float %5, float* %rt6.t1, align 4
  %rt8.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 4
  %rt9.t0 = load i8** %ptrLocalMemPtr, align 8
  %rt9.t1 = load i8** %rt8.t1, align 8
  %rt12.t0 = bitcast i8* %rt9.t0 to i32*
  %rt12.t1 = bitcast i8* %rt9.t1 to i32*
  store i32 6, i32* %rt12.t0, align 4
  store i32 6, i32* %rt12.t1, align 4
  ret void
}


define internal void @_Z_ocelotTranslated_convergence_opt3_ws2(%LLVMContext* %__ctaContext) nounwind align 1 {
WarpSynchronousEntry:
  %ptrLocalMemPtr = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 4
  %localMemPtr.0 = load i8** %ptrLocalMemPtr, align 8
  %ptr = getelementptr i8* %localMemPtr.0, i64 4
  %ptrEntryPoint = bitcast i8* %ptr to i32*
  %warpEntryId = load i32* %ptrEntryPoint, align 4
  %warpEntryPoint = and i32 %warpEntryId, 65535
  %rt0.t05 = bitcast %LLVMContext* %__ctaContext to i32*
  %rt0.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 0, i32 0
  %rt1.t0 = load i32* %rt0.t05, align 4
  %rt1.t1 = load i32* %rt0.t1, align 4
  %r1.t0 = sitofp i32 %rt1.t0 to float
  %r1.t1 = sitofp i32 %rt1.t1 to float
  %0 = insertelement <2 x float> undef, float %r1.t0, i32 0
  %1 = insertelement <2 x float> %0, float %r1.t1, i32 1
  %2 = fadd <2 x float> %1, %1
  %3 = fadd <2 x float> %2, <float 1.000000e+00, float 1.000000e+00>
  %4 = extractelement <2 x float> %3, i32 0
  %5 = extractelement <2 x float> %3, i32 1
  %rt2.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 8
  %rt2.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 8
  %rt3.t0 = load i8** %rt2.t0, align 8
  %rt3.t1 = load i8** %rt2.t1, align 8
  %rt4.t0 = bitcast i8* %rt3.t0 to i64*
  %rt4.t1 = bitcast i8* %rt3.t1 to i64*
  %r5.t0 = load i64* %rt4.t0, align 8
  %r5.t1 = load i64* %rt4.t1, align 8
  %rt5.t0 = sext i32 %rt1.t0 to i64
  %rt5.t1 = sext i32 %rt1.t1 to i64
  %r7.t0 = mul i64 %rt5.t0, 4
  %r7.t1 = mul i64 %rt5.t1, 4
  %r8.t0 = add i64 %r5.t0, %r7.t0
  %r8.t1 = add i64 %r5.t1, %r7.t1
  %rt6.t0 = inttoptr i64 %r8.t0 to float*
  %rt6.t1 = inttoptr i64 %r8.t1 to float*
  store float %4, float* %rt6.t0, align 4
  store float %5, float* %rt6.t1, align 4
  %rt8.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 4
  %rt9.t0 = load i8** %ptrLocalMemPtr, align 8
  %rt9.t1 = load i8** %rt8.t1, align 8
  %rt12.t0 = bitcast i8* %rt9.t0 to i32*
  %rt12.t1 = bitcast i8* %rt9.t1 to i32*
  store i32 6, i32* %rt12.t0, align 4
  store i32 6, i32* %rt12.t1, align 4
  ret void
}

nterleavedInstructions()
(0.008019) LLVMUniformVectorization.cpp:454:    traversal contains:
(0.008028) LLVMUniformVectorization.cpp:459:    - $BB_1_0002
(0.008041) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_ws_2]
(0.008052) LLVMUniformVectorization.cpp:459:    - $BB_1_0002_exit
(0.008063) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_exit_ws_2]
(0.008072) LLVMUniformVectorization.cpp:459:    - exit
(0.008082) LLVMUniformVectorization.cpp:472:      [ constructed as exit_ws_2]
(0.008092) LLVMUniformVectorization.cpp:459:    - $BB_1_0002_entry
(0.008103) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_entry_ws_2]
(0.008307) LLVMUniformVectorization.cpp:242:  Updating data dependencies among replicated instructions
(0.008327) LLVMUniformVectorization.cpp:245:  Updating control flow among warp-synchronous replicated blocks
(0.008342) LLVMUniformVectorization.cpp:248:  Vectorizing replicated instruction bundles
(0.008401) LLVMUniformVectorization.cpp:255:  Removing superfluous scalar blocks
(0.008423) LLVMUniformVectorization.cpp:258:  Creating scheduler block
(0.008431) LLVMUniformVectorization.cpp:1373: Updating subkernel entry points
(0.008450) LLVMUniformVectorization.cpp:1399: There are 1 entry points
(0.008461) LLVMUniformVectorization.cpp:1344: seeking label BB_1_0002_entry_ws
(0.008469) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.008478) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_ws_2
(0.008487) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_exit_ws_2
(0.008495) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.008504) LLVMUniformVectorization.cpp:1414: Created switch with 1 cases
(0.008513) LLVMUniformVectorization.cpp:1421: adding successor 0 - $BB_1_0002_entry_ws_2
(0.008522) LLVMUniformVectorization.cpp:1424: Created large switch statement in scheduler
(0.008529) LLVMUniformVectorization.cpp:261:  Finalizing subkernel
(0.008537) LLVMUniformVectorization.cpp:265:  end vectorization _Z_ocelotTranslated_convergence_opt3_ws2

(0.010386) LLVMDynamicTranslationCache.cpp:1215: performed transformations
(0.013752) LLVMDynamicTranslationCache.cpp:126:  inserting translation 0 with 72 bytes of local memory
(0.013772) LLVMDynamicExecutionManager.cpp:103:  Unlocking dynamic execution manager
(0.013783) LLVMDynamicExecutive.cpp:242:   obtained translation. Executing warp on subkernel 0
(0.013794) LLVMDynamicExecutive.cpp:269:   thread(0, 0, 0) [cta 0] exited with code exit - resume point: 0
(0.013805) LLVMDynamicExecutive.cpp:269:   thread(1, 0, 0) [cta 0] exited with code exit - resume point: 0
(0.013817) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 0
(0.013825) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.013834) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 0
(0.013842) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 0, ws: 2)
(0.013852) LLVMDynamicExecutive.cpp:389:  hit local translation cache
(0.013860) LLVMDynamicExecutive.cpp:242:   obtained translation. Executing warp on subkernel 0
(0.013869) LLVMDynamicExecutive.cpp:269:   thread(2, 0, 0) [cta 0] exited with code exit - resume point: 0
(0.013878) LLVMDynamicExecutive.cpp:269:   thread(3, 0, 0) [cta 0] exited with code exit - resume point: 0
Pass/Fail : Pass

INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaMalloc 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLLVMInstructions
INFO     Test completed in 0.0306949615479 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestLLVMInstructions

Description: A test for the assembly code generation and automatic 
             verfication of individual LLVM instructions. Test Points: 1) For each 
             instruction, generate several assembly strings using the 
             instruction's toString method, make sure that these pass the valid() 
             check, compare to references from the LLVM manual.


Test Seed : 1305582754
Test time : 0.000927925

Status :  Checked instruction "<result> = add i32 4, %var"
Add Instruction Passed
 Checked instruction "%ptr = alloca i32"
 Checked instruction "%ptr = alloca i32, i32 4"
 Checked instruction "%ptr = alloca i32, i32 4, align 1024"
 Checked instruction "%ptr = alloca i32, align 1024"
Alloca Instruction Passed
 Checked instruction "<result> = and i32 4, %var"
 Checked instruction "<result> = and i32 15, 40"
 Checked instruction "<result> = and i32 4, 8"
And Instruction Passed
 Checked instruction "<result> = ashr i32 4, 1"
 Checked instruction "<result> = ashr i8 -2, 1"
 Checked instruction "<result> = ashr < 2 x i32 > < i32 -2, i32 4 >, < i32 1, i32 3 >"
Ashr Instruction Passed
 Checked instruction "%X = bitcast i8 -1 to i8"
 Checked instruction "%Z = bitcast < 2 x i32 > %V to i64"
Bitcast Instruction Passed
 Checked instruction "br i1 %cond, label %IfEqual, label %IfUnequal"
Br Instruction Passed
 Checked instruction "%retval = call i32 @test(i32 %argc)"
 Checked instruction "call i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42)"
 Checked instruction "%X = tail call i32 @foo()"
 Checked instruction "%Y = tail call fastcc i32 @foo()"
 Checked instruction "call void @foo(i8 97 signext)"
 Checked instruction "%r = call %struct.A @foo()"
 Checked instruction "call void @foo() noreturn"
 Checked instruction "%ZZ = call zeroext i32 @bar()"
Call Instruction Passed
 Checked instruction "%result = extractelement < 4 x i32 > %vec, i32 0"
Extractelement Instruction Passed
 Checked instruction "%result = extractvalue { i32, float } %agg, 0"
Extractvalue Instruction Passed
 Checked instruction "<result> = fadd float 0x4010000000000000, %var"
Fadd Instruction Passed
 Checked instruction "<result> = fcmp oeq float 0x4010000000000000, 0x4014000000000000"
 Checked instruction "<result> = fcmp one float 0x4010000000000000, 0x4014000000000000"
 Checked instruction "<result> = fcmp olt float 0x4010000000000000, 0x4014000000000000"
 Checked instruction "<result> = fcmp ueq float 0x3ff0000000000000, 0x4000000000000000"
Fcmp Instruction Passed
 Checked instruction "<result> = fdiv float 0x4010000000000000, %var"
Fdiv Instruction Passed
 Checked instruction "<result> = fmul float 0x4010000000000000, %var"
Fmul Instruction Passed
 Checked instruction "%X = fpext float 0x400921cac0000000 to double"
 Checked instruction "%Y = fpext float 0x3ff0000000000000 to float"
Fpext Instruction Passed
 Checked instruction "%X = fptosi double 0xc05ec00000000000 to i32"
Fptosi Instruction Passed
 Checked instruction "%X = fptoui double 0x405ec00000000000 to i32"
Fptoui Instruction Passed
 Checked instruction "%X = fptrunc double 0x405ec00000000000 to float"
Fptrunc Instruction Passed
 Checked instruction "free [ 4 x i8 ]* %array"
Free Instruction Passed
 Checked instruction "<result> = frem float 0x4010000000000000, %var"
Frem Instruction Passed
 Checked instruction "<result> = fsub float 0x0, %val"
Fsub Instruction Passed
 Checked instruction "%vptr = getelementptr { i32, < 2 x i8 > }* %svptr, i32 0, i32 1, i32 1"
 Checked instruction "%eptr = getelementptr [ 12 x i8 ]* %aptr, i32 0, i32 1"
Getelementptr Instruction Passed
 Checked instruction "<result> = icmp ne float* %X, %X"
Icmp Instruction Passed
 Checked instruction "%result = insertelement < 4 x i32 > %vec, i32 1, i32 0"
Insertelement Instruction Passed
 Checked instruction "%result = insertvalue { i32, float } %agg, i32 1, 0"
Insertvalue Instruction Passed
 Checked instruction "%Y = inttoptr i64 0 to i32*"
Inttoptr Instruction Passed
 Checked instruction "%retval = invoke i32 @Test(i32 15) to label %Continue unwind label %TestCleanup"
Invoke Instruction Passed
 Checked instruction "%val = load i32* %ptr"
Load Instruction Passed
 Checked instruction "<result> = lshr i8 -2, 1"
Lshr Instruction Passed
 Checked instruction "%array2 = malloc [ 12 x i8 ], i32 %size"
Malloc Instruction Passed
 Checked instruction "<result> = mul i32 4, %var"
Mul Instruction Passed
 Checked instruction "<result> = or i32 15, 40"
Or Instruction Passed
 Checked instruction "%indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]"
Phi Instruction Passed
 Checked instruction "%Y = ptrtoint i32* %x to i64"
Prtoint Instruction Passed
 Checked instruction "ret void"
Ret Instruction Passed
 Checked instruction "<result> = sdiv i32 4, %var"
Sdiv Instruction Passed
 Checked instruction "%X = select i1 1, i8 17, i8 42"
Select Instruction Passed
 Checked instruction "%X = sext i8 -1 to i16"
Sext Instruction Passed
 Checked instruction "<result> = shl i32 1, 32"
Shl Instruction Passed
 Checked instruction "%result = shufflevector < 4 x i32 > %v1, < 4 x i32 > %v2, < 8 x i32 > < i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 >"
ShuffleVector Instruction Passed
 Checked instruction "%X = sitofp i32 257 to float"
Sitofp Instruction Passed
 Checked instruction "<result> = srem i32 4, %var"
Srem Instruction Passed
 Checked instruction "store i32 3, i32* %ptr"
Store Instruction Passed
 Checked instruction "<result> = sub i32 4, %var"
Sub Instruction Passed
 Checked instruction "switch i32 %val, label %otherwise [ i32 0, label %onzero i32 1, label %onone i32 2, label %ontwo ]"
Switch Instruction Passed
 Checked instruction "%Y = trunc i32 123 to i1"
Trunc Instruction Passed
 Checked instruction "<result> = udiv i32 4, %var"
Udiv Instruction Passed
 Checked instruction "%Y = uitofp i8 -1 to double"
Uitofp Instruction Passed
 Checked instruction "unreachable"
Unreachable Instruction Passed
 Checked instruction "unwind"
Unwind Instruction Passed
 Checked instruction "<result> = urem i32 4, %var"
Urem Instruction Passed
 Checked instruction "%tmp = va_arg i8** %ap, i32"
VarArg Instruction Passed
 Checked instruction "<result> = xor i32 -1, %V"
Xor Instruction Passed
 Checked instruction "%X = zext i32 257 to i64"
Zext Instruction Passed



INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestDeviceSwitching
INFO     Test completed in 0.0306951999664 seconds
INFO      It produced the following output:
(0.001637) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel 'increment'.
(0.001663) LLVMDynamicTranslationCache.cpp:145:  LLVMDynamicTranslationCache::loadModule() - simpleKernels
(0.001678) KernelPartitioningPass.cpp:593:  Run on kernel 'increment'
/*
* Ocelot Version : 2.0.896
*/
.entry increment(.param  .u64 memory)
{

	.reg .u64 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	$BB_1_0002:				/* Entry */ 
		ld.param.u64 %r0, [memory];
		ld.global.u32 %r1, [%r0 + 0];
		add.u32 %r2, %r1, 1;
		st.global.u32 [%r0 + 0], %r2;
	$BB_1_0003:				/* Exit */ 
		exit;
}
(0.001759) KernelPartitioningPass.cpp:596:  


(0.001830) KernelPartitioningPass.cpp:145:    Spill region size is 16
(0.001840) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.001848) KernelPartitioningPass.cpp:159:   block entry
(0.001856) KernelPartitioningPass.cpp:159:   block exit
(0.001863) KernelPartitioningPass.cpp:159:   block $BB_1_0002
(0.001871) KernelPartitioningPass.cpp:159:   block $BB_1_0003
(0.001933) KernelPartitioningPass.cpp:185:  identifying transition points
(0.001956) KernelPartitioningPass.cpp:199:   block $BB_1_0002
(0.001971) KernelPartitioningPass.cpp:199:   block $BB_1_0003
(0.001984) KernelPartitioningPass.cpp:229:   block $BB_1_0002
(0.001995) KernelPartitioningPass.cpp:229:   block $BB_1_0003
(0.002012) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = st
(0.002027) KernelPartitioningPass.cpp:360:    terminator->toString() = st.global.u32 [%r0 + 0], %r2
(0.002035) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.002042) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.002055) KernelPartitioningPass.cpp:549:  created exit in block '$BB_1_0003_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry increment(.param  .u64 memory)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[16];

	.reg .u64 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	$BB_1_0002:				/* Entry */ 
		ld.param.u64 %r0, [memory];
		ld.global.u32 %r1, [%r0 + 0];
		add.u32 %r2, %r1, 1;
		st.global.u32 [%r0 + 0], %r2;
	$BB_1_0003:				/* Exit */ 
		bra $BB_1_0003_exit;
	$BB_1_0002_entry:				/* entryId: 0 */ 
		bra $BB_1_0002;
	$BB_1_0003_entry:				/* entryId: 1 */ 
		bra $BB_1_0003;
	$BB_1_0002_exit:
	$BB_1_0003_exit:				/* exit */ 
		mov.u32 %r3, _Zocelot_resume_status;
		st.local.u32 [%r3 + 0], 6;
		yield;
}
(0.002258) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 1, 1
(0.002268) LLVMDynamicExecutionManager.cpp:61:     block dim: 1, 1, 1
(0.002277) LLVMDynamicExecutionManager.cpp:62:     entry id: 0
(0.002285) LLVMDynamicExecutionManager.cpp:63:     local memory size: 24 bytes
(0.002292) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 0 bytes 
(0.002300) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.002309) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.002320) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 24, total threads: 1, shared memory size: 0
(0.002331) LLVMDynamicExecutive.cpp:207:  execute()
(0.002340) LLVMDynamicExecutive.cpp:340:  formed warp of size 1 with entryId 0
(0.002347) LLVMDynamicExecutive.cpp:218:   formed warp with 1 threads
(0.002357) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 1 on hyperblockId 0
(0.002366) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 0, ws: 1)
(0.002374) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.002382) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 0, warpsize: 1)
(0.002390) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager
(0.003463) LLVMDynamicTranslationCache.cpp:1037: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_increment( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt1 = load i8** %rt0;
	%rt2 = bitcast i8* %rt1 to i64*;
	%r0 = load i64* %rt2, align 8;
	%rt3 = inttoptr i64 %r0 to i32*;
	%r1 = load i32* %rt3, align 4;
	%r2 = add i32 %r1, 1;
	%rt4 = inttoptr i64 %r0 to i32*;
	store i32 %r2, i32* %rt4, align 4;
	br label %$BB_1_0003;
$BB_1_0003:
	br i1 1, label %$BB_1_0003_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0003_entry:
	br label %$BB_1_0003;
$BB_1_0002_exit:
	ret void;
$BB_1_0003_exit:
	%r3 = bitcast i32 0 to i32;
	%rt5 = zext i32 %r3 to i64;
	%rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt7 = load i8** %rt6;
	%rt8 = ptrtoint i8* %rt7 to i64;
	%rt9 = add i64 %rt5, %rt8;
	%rt10 = inttoptr i64 %rt9 to i32*;
	store i32 6, i32* %rt10, align 4;
	br label %exit;
exit:
	ret void;

}

(0.006056) LLVMUniformVectorization.cpp:222:  Vectorization: _Z_ocelotTranslated_increment_opt3_ws1
(0.006067) LLVMUniformVectorization.cpp:226:  Breadth first traversal:
(0.006086) LLVMUniformVectorization.cpp:229:  Creating prolog block to replace scheduler
(0.006097) LLVMUniformVectorization.cpp:232:  Loading thread-local values
(0.006105) LLVMUniformVectorization.cpp:383:  loadThreadLocalArguments
(0.006144) LLVMUniformVectorization.cpp:255:  Removing superfluous scalar blocks
(0.006154) LLVMUniformVectorization.cpp:258:  Creating scheduler block
(0.006164) LLVMUniformVectorization.cpp:1373: Updating subkernel entry points
(0.006179) LLVMUniformVectorization.cpp:1399: There are 2 entry points
(0.006189) LLVMUniformVectorization.cpp:1344: seeking label BB_1_0002_entry_ws
(0.006197) LLVMUniformVectorization.cpp:1356: possible entTestDeviceSwitching: ocelot/analysis/implementation/LLVMUniformVectorization.cpp:1407: void analysis::LLVMUniformVectorization::Translation::updateSubkernelEntries(): Assertion `successor' failed.
ry block: WarpSynchronousEntry
(0.006215) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002
(0.006223) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0003
(0.006230) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_entry
(0.006237) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0003_entry
(0.006244) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_exit
(0.006251) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0003_exit
(0.006258) LLVMUniformVectorization.cpp:1356: possible entry block: exit
(0.006265) LLVMUniformVectorization.cpp:1363: failed to find warp block with entry ID 0
Stack dump:
0.	Running pass 'Ocelot LLVM Uniform Vectorization' on function '@_Z_ocelotTranslated_increment_opt3_ws1'

INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestEmulator
INFO     Test completed in 0.0245389938354 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestEmulator

Description: 


Test Seed : 1305582754
Test time : 0.00210524

Status : Test output:
10 registers
Register test passed
Load test passed
Store test passed
no errors
Full kernel test passed



INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestFunctionCall
INFO     Test completed in 0.0466458797455 seconds
INFO      It produced the following output:
(0.002849) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel 'kernel'.
(0.002883) LLVMDynamicTranslationCache.cpp:145:  LLVMDynamicTranslationCache::loadModule() - simpleFunc.cu
(0.002899) KernelPartitioningPass.cpp:593:  Run on kernel 'square'
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .f32 __cudaretf_square) square(.param  .f32 __cudaparmf1_square)
{

	.reg .f32 %r0;
	.reg .f32 %r1;
	.reg .f32 %r2;
	$BB_1_0002:				/* $LDWbegin_square */ 
		ld.param.f32 %r0, [__cudaparmf1_square];
		mov.f32 %r1, %r0;
		mul.f32 %r2, %r1, %r1;
		st.param.f32 [__cudaretf_square], %r2;
		ret;
}
(0.002986) KernelPartitioningPass.cpp:596:  


(0.003054) KernelPartitioningPass.cpp:145:    Spill region size is 16
(0.003064) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.003073) KernelPartitioningPass.cpp:159:   block entry
(0.003082) KernelPartitioningPass.cpp:159:   block exit
(0.003089) KernelPartitioningPass.cpp:159:   block $BB_1_0002
(0.003145) KernelPartitioningPass.cpp:185:  identifying transition points
(0.003160) KernelPartitioningPass.cpp:199:   block $BB_1_0002
(0.003175) KernelPartitioningPass.cpp:229:   block $BB_1_0002
(0.003194) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = ret
(0.003204) KernelPartitioningPass.cpp:360:    terminator->toString() = ret
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .f32 __cudaretf_square) square(.param  .f32 __cudaparmf1_square)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[16];

	.reg .f32 %r0;
	.reg .f32 %r1;
	.reg .f32 %r2;
	$BB_1_0002:				/* $LDWbegin_square */ 
		ld.param.f32 %r0, [__cudaparmf1_square];
		mov.f32 %r1, %r0;
		mul.f32 %r2, %r1, %r1;
		st.param.f32 [__cudaretf_square], %r2;
		ret;
	$BB_1_0002_entry:				/* entryId: 0 */ 
		bra $BB_1_0002;
	$BB_1_0002_exit:
}
(0.003367) KernelPartitioningPass.cpp:593:  Run on kernel 'kernel'
/*
* Ocelot Version : 2.0.896
*/
.entry kernel(.param  .u64 __cudaparm_kernel_A,
		.param  .s32 __cudaparm_kernel_N)
{

	.param  .f32 __cudaparma1_square;
	.param  .f32 __cudareta_square;
	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .pred %p6;
	.reg .u32 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u64 %r10;
	.reg .f32 %r11;
	.reg .f32 %r12;
	.reg .f32 %r13;
	$BB_2_0002:				/* $LDWbegin_kernel */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %tid.x;
		add.u32 %r4, %r3, %r2;
		ld.param.s32 %r5, [__cudaparm_kernel_N];
		setp.le.s32 %p6, %r5, %r4;
		@%p6 bra $BB_2_0004;
	$BB_2_0003:
		mul.lo.u32 %r7, %r4, 4;
		cvt.u64.u32 %r8, %r7;
		ld.param.u64 %r9, [__cudaparm_kernel_A];
		add.u64 %r10, %r8, %r9;
		ld.global.f32 %r11, [%r10 + 0];
		st.param.f32 [__cudaparma1_square], %r11;
		call.uni (__cudareta_square), square, (__cudaparma1_square);
		ld.param.f32 %r12, [__cudareta_square];
		mov.f32 %r13, %r12;
		st.global.f32 [%r10 + 0], %r13;
	$BB_2_0004:				/* $Lt_1_1026 */ 
		exit;
}
(0.003560) KernelPartitioningPass.cpp:596:  


(0.003727) KernelPartitioningPass.cpp:145:    Spill region size is 104
(0.003737) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.003744) KernelPartitioningPass.cpp:159:   block entry
(0.003751) KernelPartitioningPass.cpp:159:   block exit
(0.003758) KernelPartitioningPass.cpp:159:   block $BB_2_0002
(0.003765) KernelPartitioningPass.cpp:159:   block $BB_2_0003
(0.003772) KernelPartitioningPass.cpp:159:   block $BB_2_0004
(0.003939) KernelPartitioningPass.cpp:185:  identifying transition points
(0.003958) KernelPartitioningPass.cpp:199:   block $BB_2_0002
(0.003971) KernelPartitioningPass.cpp:199:   block $BB_2_0003
(0.003985) KernelPartitioningPass.cpp:199:   block $BB_2_0004
(0.003997) KernelPartitioningPass.cpp:229:   block $BB_2_0002
(0.004008) KernelPartitioningPass.cpp:229:   block $BB_2_0003
(0.004018) KernelPartitioningPass.cpp:229:   block $BB_2_0004
(0.004039) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcTestFunctionCall: ocelot/executive/implementation/LLVMDynamicTranslationCache.cpp:1000: void executive::setupCallTargets(ir::PTXKernel&, const executive::LLVMDynamicTranslationCache&): Assertion `0 && "arbitrary function calls not yet supported"' failed.
ode = bra
(0.004072) KernelPartitioningPass.cpp:360:    terminator->toString() = @%p6 bra $BB_2_0004
(0.004093) KernelPartitioningPass.cpp:549:  created exit in block '$BB_2_0002_exit' with code 2
(0.004102) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = st
(0.004117) KernelPartitioningPass.cpp:360:    terminator->toString() = st.global.f32 [%r10 + 0], %r13
(0.004125) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.004132) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.004145) KernelPartitioningPass.cpp:549:  created exit in block '$BB_2_0004_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry kernel(.param  .u64 __cudaparm_kernel_A,
		.param  .s32 __cudaparm_kernel_N)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[104];

	.param  .f32 __cudaparma1_square;
	.param  .f32 __cudareta_square;
	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .pred %p6;
	.reg .u32 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u64 %r10;
	.reg .f32 %r11;
	.reg .f32 %r12;
	.reg .f32 %r13;
	.reg .u32 %r14;
	.reg .u32 %r15;
	.reg .u32 %r16;
	.reg .u32 %r17;
	.reg .u32 %r18;
	$BB_2_0002:				/* $LDWbegin_kernel */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %tid.x;
		add.u32 %r4, %r3, %r2;
		ld.param.s32 %r5, [__cudaparm_kernel_N];
		setp.le.s32 %p6, %r5, %r4;
		@%p6 bra $BB_2_0004;
	$BB_2_0003:
		mul.lo.u32 %r7, %r4, 4;
		cvt.u64.u32 %r8, %r7;
		ld.param.u64 %r9, [__cudaparm_kernel_A];
		add.u64 %r10, %r8, %r9;
		ld.global.f32 %r11, [%r10 + 0];
		st.param.f32 [__cudaparma1_square], %r11;
		call.uni (__cudareta_square), square, (__cudaparma1_square);
		ld.param.f32 %r12, [__cudareta_square];
		mov.f32 %r13, %r12;
		st.global.f32 [%r10 + 0], %r13;
	$BB_2_0004:				/* $Lt_1_1026 */ 
		bra $BB_2_0004_exit;
	$BB_2_0004_exit:				/* exit */ 
		mov.u32 %r18, _Zocelot_resume_status;
		st.local.u32 [%r18 + 0], 6;
		yield;
	$BB_2_0002_entry:				/* entryId: 0 */ 
		bra $BB_2_0002;
	$BB_2_0003_entry:				/* entryId: 1 */ 
		mov.s32 %r14, _Zocelot_spill_area;
		ld.local.u32 %r4, [%r14 + 32];
		ld.local.f32 %r0, [%r14 + 0];
		bra $BB_2_0003;
	$BB_2_0004_entry:				/* entryId: 2 */ 
		bra $BB_2_0004;
	$BB_2_0002_exit:				/* divergent branch */ 
		mov.s32 %r15, _Zocelot_spill_area;
		st.local.f32 [%r15 + 0], %r0;
		st.local.u32 [%r15 + 32], %r4;
		selp.s32 %r16, 2, 1, %p6;
		mov.u32 %r17, _Zocelot_resume_point;
		st.local.u32 [%r17 + 0], %r16;
		mov.u32 %r17, _Zocelot_resume_status;
		st.local.u32 [%r17 + 0], 2;
		yield;
	$BB_2_0003_exit:
}
(0.004782) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 1, 1
(0.004793) LLVMDynamicExecutionManager.cpp:61:     block dim: 32, 1, 1
(0.004803) LLVMDynamicExecutionManager.cpp:62:     entry id: 65536
(0.004812) LLVMDynamicExecutionManager.cpp:63:     local memory size: 112 bytes
(0.004821) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 0 bytes 
(0.004829) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.004840) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.004853) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 112, total threads: 32, shared memory size: 0
(0.004873) LLVMDynamicExecutive.cpp:207:  execute()
(0.004884) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 65536
(0.004893) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.004903) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 65536
(0.004913) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 65536, ws: 2)
(0.004922) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.004931) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 65536, warpsize: 2)
(0.004939) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager

INFO     Running test program /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestIndirectFunctionCall 
INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestPTXAssembly
INFO     Test completed in 0.0412230491638 seconds
INFO      It produced the following output:
(0.004407) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel 'test'.
(0.004430) LLVMDynamicTranslationCache.cpp:145:  LLVMDynamicTranslationCache::loadModule() - TestVectorElements-u32
(0.004441) KernelPartitioningPass.cpp:593:  Run on kernel 'test'
/*
* Ocelot Version : 2.0.896
*/
.entry test(.param  .u64 out,
		.param  .u64 in)
{

	.reg .u64 %r0;
	.reg .u64 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .u32 %r9;
	$BB_1_0002:
		ld.param.u64 %r0, [in];
		ld.param.u64 %r1, [out];
		ld.global.v4.u32 {%r2, %r3, %r4, %r5}, [%r0 + 0];
		mov.u32 %r6, %r3;
		mov.u32 %r7, %r4;
		mov.u32 %r8, %r5;
		mov.u32 %r9, %r2;
		st.global.v4.u32 [%r1 + 0], {%r6, %r7, %r8, %r9};
		exit;
}
(0.004550) KernelPartitioningPass.cpp:596:  


(0.004648) KernelPartitioningPass.cpp:145:    Spill region size is 72
(0.004658) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.004666) KernelPartitioningPass.cpp:159:   block entry
(0.004674) KernelPartitioningPass.cpp:159:   block exit
(0.004681) KernelPartitioningPass.cpp:159:   block $BB_1_0002
(0.004780) KernelPartitioningPass.cpp:185:  identifying transition points
(0.004794) KernelPartitioningPass.cpp:199:   block $BB_1_0002
(0.004810) KernelPartitioningPass.cpp:229:   block $BB_1_0002
(0.004827) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.004837) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.004851) KernelPartitioningPass.cpp:549:  created exit in block '$BB_1_0002_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry test(.param  .u64 out,
		.param  .u64 in)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[72];

	.reg .u64 %r0;
	.reg .u64 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .u32 %r9;
	.reg .u32 %r10;
	$BB_1_0002:
		ld.param.u64 %r0, [in];
		ld.param.u64 %r1, [out];
		ld.global.v4.u32 {%r2, %r3, %r4, %r5}, [%r0 + 0];
		mov.u32 %r6, %r3;
		mov.u32 %r7, %r4;
		mov.u32 %r8, %r5;
		mov.u32 %r9, %r2;
		st.global.v4.u32 [%r1 + 0], {%r6, %r7, %r8, %r9};
		bra $BB_1_0002_exit;
	$BB_1_0002_entry:				/* entryId: 0 */ 
		bra $BB_1_0002;
	$BB_1_0002_exit:				/* exit */ 
		mov.u32 %r10, _Zocelot_resume_status;
		st.local.u32 [%r10 + 0], 6;
		yield;
}
(0.005129) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 1, 1
(0.005139) LLVMDynamicExecutionManager.cpp:61:     block dim: 1, 1, 1
(0.005147) LLVMDynamicExecutionManager.cpp:62:     entry id: 0
(0.005155) LLVMDynamicExecutionManager.cpp:63:     local memory size: 80 bytes
(0.005163) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 0 bytes 
(0.005170) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.005181) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.005191) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 80, total threads: 1, shared memory size: 0
(0.005205) LLVMDynamicExecutive.cpp:207:  execute()
(0.005217) LLVMDynamicExecutive.cpp:340:  formed warp of size 1 with entryId 0
(0.005225) LLVMDynamicExecutive.cpp:218:   formed warp with 1 threads
(0.005233) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 1 on hyperblockId 0
(0.005242) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 0, ws: 1)
(0.005250) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.005259) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 0, warpsize: 1)
(0.005267) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager
(0.006593) LLVMDynamicTranslationCache.cpp:1037: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_test( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt2 = load i8** %rt1;
	%rt0 = getelementptr i8* %rt2, i32 8;
	%rt3 = bitcast i8* %rt0 to i64*;
	%r0 = load i64* %rt3, align 8;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt5 = load i8** %rt4;
	%rt6 = bitcast i8* %rt5 to i64*;
	%r1 = load i64* %rt6, align 8;
	%rt8 = inttoptr i64 %r0 to < 4 x i32 >*;
	%rt7 = load < 4 x i32 >* %rt8, align 16;
	%r2 = extractelement < 4 x i32 > %rt7, i32 0;
	%r3 = extractelement < 4 x i32 > %rt7, i32 1;
	%r4 = extractelement < 4 x i32 > %rt7, i32 2;
	%r5 = extractelement < 4 x i32 > %rt7, i32 3;
	%r6 = bitcast i32 %r3 to i32;
	%r7 = bitcast i32 %r4 to i32;
	%r8 = bitcast i32 %r5 to i32;
	%r9 = bitcast i32 %r2 to i32;
	%rt9 = inttoptr i64 %r1 to < 4 x i32 >*;
	%rt10 = insertelement < 4 x i32 > < i32 0, i32 0, i32 0, i32 0 >, i32 %r6, i32 0;
	%rt11 = insertelement < 4 x i32 > %rt10, i32 %r7, i32 1;
	%rt12 = insertelement < 4 x i32 > %rt11, i32 %r8, i32 2;
	%rt13 = insertelement < 4 x i32 > %rt12, i32 %r9, i32 3;
	store < 4 x i32 > %rt13, < 4 x i32 >* %rt9, align 16;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r10 = bitcast i32 0 to i32;
	%rt14 = zext i32 %r10 to i64;
	%rt15 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt16 = load i8** %rt15;
	%rt17 = ptrtoint i8* %rt16 to i64;
	%rt18 = add i64 %rt14, %rt17;
	%rt19 = inttoptr i64 %rt18 to i32*;
	store i32 6, i32* %rt19, align 4;
	br label %exit;
exit:
	ret void;

}

(0.009302) LLVMUniformVectorization.cpp:222:  Vectorization: _Z_ocelotTranslated_test_opt3_ws1
(0.009314) LLVMUniformVectorization.cpp:226:  Breadth first traversal:
(0.009329) LLVMUniformVectorization.cpp:229:  CTestPTXAssembly: ocelot/analysis/implementation/LLVMUniformVectorization.cpp:1407: void analysis::LLVMUniformVectorization::Translation::updateSubkernelEntries(): Assertion `successor' failed.
reating prolog block to replace scheduler
(0.009350) LLVMUniformVectorization.cpp:232:  Loading thread-local values
(0.009359) LLVMUniformVectorization.cpp:383:  loadThreadLocalArguments
(0.009392) LLVMUniformVectorization.cpp:255:  Removing superfluous scalar blocks
(0.009402) LLVMUniformVectorization.cpp:258:  Creating scheduler block
(0.009411) LLVMUniformVectorization.cpp:1373: Updating subkernel entry points
(0.009427) LLVMUniformVectorization.cpp:1399: There are 1 entry points
(0.009438) LLVMUniformVectorization.cpp:1344: seeking label BB_1_0002_entry_ws
(0.009446) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.009453) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002
(0.009461) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_entry
(0.009468) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_exit
(0.009475) LLVMUniformVectorization.cpp:1356: possible entry block: exit
(0.009482) LLVMUniformVectorization.cpp:1363: failed to find warp block with entry ID 0
Stack dump:
0.	Running pass 'Ocelot LLVM Uniform Vectorization' on function '@_Z_ocelotTranslated_test_opt3_ws1'

INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaSequence
INFO     Test completed in 0.0615921020508 seconds
INFO      It produced the following output:
Loaded libcuda.so explicitly; unloading now.
A_host = 0x3230120
A_gpu = 0x322f200
(0.008775) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel 'sequence'.
(0.008798) LLVMDynamicTranslationCache.cpp:145:  LLVMDynamicTranslationCache::loadModule() - sequence.cu
(0.008812) KernelPartitioningPass.cpp:593:  Run on kernel 'v4sequence'
/*
* Ocelot Version : 2.0.896
*/
.entry v4sequence(.param  .u64 __cudaparm_v4sequence_A,
		.param  .s32 __cudaparm_v4sequence_N)
{

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u64 %r5;
	.reg .u64 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	.reg .u32 %r9;
	.reg .u32 %r10;
	.reg .u32 %r11;
	.reg .u32 %r12;
	.reg .u32 %r13;
	.reg .u32 %r14;
	.reg .u32 %r15;
	$BB_4_0002:				/* $LDWbegin_v4sequence */ 
		mov.u32 %r0, %tid.x;
		mov.u32 %r1, %ctaid.x;
		mov.u32 %r2, %ntid.x;
		mul.lo.u32 %r3, %r1, %r2;
		add.u32 %r4, %r0, %r3;
		ld.param.u64 %r5, [__cudaparm_v4sequence_A];
		cvt.s64.s32 %r6, %r4;
		mul.wide.s32 %r7, %r4, 16;
		add.u64 %r8, %r5, %r7;
		add.s32 %r9, %r4, 1;
		mul.lo.s32 %r10, %r4, 2;
		add.s32 %r11, %r10, 2;
		mul.lo.s32 %r12, %r4, 3;
		add.s32 %r13, %r12, 3;
		mul.lo.s32 %r14, %r4, 4;
		add.s32 %r15, %r14, 4;
		st.global.v4.s32 [%r8 + 0], {%r9, %r11, %r13, %r15};
		exit;
}
(0.009047) KernelPartitioningPass.cpp:596:  


(0.010111) KernelPartitioningPass.cpp:145:    Spill region size is 120
(0.010127) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.010136) KernelPartitioningPass.cpp:159:   block entry
(0.010144) KernelPartitioningPass.cpp:159:   block exit
(0.010152) KernelPartitioningPass.cpp:159:   block $BB_4_0002
(0.010318) KernelPartitioningPass.cpp:185:  identifying transition points
(0.010345) KernelPartitioningPass.cpp:199:   block $BB_4_0002
(0.010360) KernelPartitioningPass.cpp:229:   block $BB_4_0002
(0.010398) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.010417) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.010431) KernelPartitioningPass.cpp:549:  created exit in block '$BB_4_0002_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry v4sequence(.param  .u64 __cudaparm_v4sequence_A,
		.param  .s32 __cudaparm_v4sequence_N)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[120];

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u64 %r5;
	.reg .u64 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	.reg .u32 %r9;
	.reg .u32 %r10;
	.reg .u32 %r11;
	.reg .u32 %r12;
	.reg .u32 %r13;
	.reg .u32 %r14;
	.reg .u32 %r15;
	.reg .u32 %r16;
	$BB_4_0002:				/* $LDWbegin_v4sequence */ 
		mov.u32 %r0, %tid.x;
		mov.u32 %r1, %ctaid.x;
		mov.u32 %r2, %ntid.x;
		mul.lo.u32 %r3, %r1, %r2;
		add.u32 %r4, %r0, %r3;
		ld.param.u64 %r5, [__cudaparm_v4sequence_A];
		cvt.s64.s32 %r6, %r4;
		mul.wide.s32 %r7, %r4, 16;
		add.u64 %r8, %r5, %r7;
		add.s32 %r9, %r4, 1;
		mul.lo.s32 %r10, %r4, 2;
		add.s32 %r11, %r10, 2;
		mul.lo.s32 %r12, %r4, 3;
		add.s32 %r13, %r12, 3;
		mul.lo.s32 %r14, %r4, 4;
		add.s32 %r15, %r14, 4;
		st.global.v4.s32 [%r8 + 0], {%r9, %r11, %r13, %r15};
		bra $BB_4_0002_exit;
	$BB_4_0002_entry:				/* entryId: 0 */ 
		bra $BB_4_0002;
	$BB_4_0002_exit:				/* exit */ 
		mov.u32 %r16, _Zocelot_resume_status;
		st.local.u32 [%r16 + 0], 6;
		yield;
}
(0.010839) KernelPartitioningPass.cpp:593:  Run on kernel 'testShareSimple'
/*
* Ocelot Version : 2.0.896
*/
.entry testShareSimple(.param  .u64 __cudaparm_testShareSimple_A)
{
	.shared .align 4 .b8 __cuda___cuda_local_var_28476_30_non_const_Share1056[128];

	.reg .u64 %r0;
	.reg .u32 %r1;
	.reg .u64 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u32 %r10;
	.reg .u64 %r11;
	.reg .u64 %r12;
	.reg .u64 %r13;
	.reg .u32 %r14;
	.reg .u64 %r15;
	.reg .u64 %r16;
	.reg .u64 %r17;
	.reg .u32 %r18;
	$BB_3_0002:				/* $LDWbegin_testShareSimple */ 
		mov.u64 %r0, __cuda___cuda_local_var_28476_30_non_const_Share1056;
		mov.u32 %r1, %tid.x;
		ld.param.u64 %r2, [__cudaparm_testShareSimple_A];
		mov.u32 %r3, %ctaid.x;
		mov.u32 %r4, %ntid.x;
		mul.lo.u32 %r5, %r3, %r4;
		add.u32 %r6, %r1, %r5;
		cvt.s64.s32 %r7, %r6;
		mul.wide.s32 %r8, %r6, 4;
		add.u64 %r9, %r2, %r8;
		ld.global.s32 %r10, [%r9 + 0];
		cvt.u64.u32 %r11, %r1;
		mul.wide.u32 %r12, %r1, 4;
		add.u64 %r13, %r0, %r12;
		st.shared.s32 [%r13 + 0], %r10;
		bar.sync 0;
		neg.s32 %r14, %r1;
		cvt.s64.s32 %r15, %r14;
		mul.wide.s32 %r16, %r14, 4;
		add.u64 %r17, %r0, %r16;
		ld.shared.s32 %r18, [%r17 + 124];
		st.global.s32 [%r9 + 0], %r18;
		exit;
}
(0.011055) KernelPartitioningPass.cpp:596:  


(0.011245) KernelPartitioningPass.cpp:145:    Spill region size is 144
(0.011265) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.011283) KernelPartitioningPass.cpp:159:   block entry
(0.011290) KernelPartitioningPass.cpp:159:   block exit
(0.011307) KernelPartitioningPass.cpp:159:   block $BB_3_0002
(0.011331) KernelPartitioningPass.cpp:172:  barrier in block $BB_3_0002(instruction 15)
(0.011340) KernelPartitioningPass.cpp:159:   block $BB_3_0002_bar
(0.011513) KernelPartitioningPass.cpp:185:  identifying transition points
(0.011526) KernelPartitioningPass.cpp:199:   block $BB_3_0002
(0.011540) KernelPartitioningPass.cpp:199:   block $BB_3_0002_bar
(0.011559) KernelPartitioningPass.cpp:229:   block $BB_3_0002
(0.011573) KernelPartitioningPass.cpp:229:   block $BB_3_0002_bar
(0.011603) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bar
(0.011615) KernelPartitioningPass.cpp:360:    terminator->toString() = bar.sync 0
(0.011629) KernelPartitioningPass.cpp:549:  created exit in block '$BB_3_0002_exit' with code 5
(0.011637) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.011645) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.011657) KernelPartitioningPass.cpp:549:  created exit in block '$BB_3_0002_bar_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry testShareSimple(.param  .u64 __cudaparm_testShareSimple_A)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[144];
	.shared .align 4 .b8 __cuda___cuda_local_var_28476_30_non_const_Share1056[128];

	.reg .u64 %r0;
	.reg .u32 %r1;
	.reg .u64 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u32 %r10;
	.reg .u64 %r11;
	.reg .u64 %r12;
	.reg .u64 %r13;
	.reg .u32 %r14;
	.reg .u64 %r15;
	.reg .u64 %r16;
	.reg .u64 %r17;
	.reg .u32 %r18;
	.reg .u32 %r19;
	.reg .u32 %r20;
	.reg .u32 %r21;
	.reg .u32 %r22;
	$BB_3_0002:				/* $LDWbegin_testShareSimple */ 
		mov.u64 %r0, __cuda___cuda_local_var_28476_30_non_const_Share1056;
		mov.u32 %r1, %tid.x;
		ld.param.u64 %r2, [__cudaparm_testShareSimple_A];
		mov.u32 %r3, %ctaid.x;
		mov.u32 %r4, %ntid.x;
		mul.lo.u32 %r5, %r3, %r4;
		add.u32 %r6, %r1, %r5;
		cvt.s64.s32 %r7, %r6;
		mul.wide.s32 %r8, %r6, 4;
		add.u64 %r9, %r2, %r8;
		ld.global.s32 %r10, [%r9 + 0];
		cvt.u64.u32 %r11, %r1;
		mul.wide.u32 %r12, %r1, 4;
		add.u64 %r13, %r0, %r12;
		st.shared.s32 [%r13 + 0], %r10;
		bra $BB_3_0002_exit;
	$BB_3_0002_bar:
		neg.s32 %r14, %r1;
		cvt.s64.s32 %r15, %r14;
		mul.wide.s32 %r16, %r14, 4;
		add.u64 %r17, %r0, %r16;
		ld.shared.s32 %r18, [%r17 + 124];
		st.global.s32 [%r9 + 0], %r18;
		bra $BB_3_0002_bar_exit;
	$BB_3_0002_entry:				/* entryId: 0 */ 
		bra $BB_3_0002;
	$BB_3_0002_bar_entry:				/* entryId: 1 */ 
		mov.s32 %r19, _Zocelot_spill_area;
		ld.local.u64 %r9, [%r19 + 72];
		ld.local.u32 %r1, [%r19 + 8];
		ld.local.u64 %r0, [%r19 + 0];
		bra $BB_3_0002_bar;
	$BB_3_0002_exit:				/* barrier handler */ 
		mov.s32 %r20, _Zocelot_spill_area;
		st.local.u64 [%r20 + 0], %r0;
		st.local.u32 [%r20 + 8], %r1;
		st.local.u64 [%r20 + 72], %r9;
		mov.u32 %r21, _Zocelot_resume_point;
		st.local.u32 [%r21 + 0], 1;
		mov.u32 %r21, _Zocelot_resume_status;
		st.local.u32 [%r21 + 0], 5;
		yield;
	$BB_3_0002_bar_exit:				/* exit */ 
		mov.u32 %r22, _Zocelot_resume_status;
		st.local.u32 [%r22 + 0], 6;
		yield;
}
(0.012264) KernelPartitioningPass.cpp:593:  Run on kernel 'testShr'
/*
* Ocelot Version : 2.0.896
*/
.entry testShr(.param  .u64 __cudaparm_testShr_A)
{
	.shared .align 4 .b8 __cuda___cuda_local_var_28496_30_non_const_storage1208[1024];

	.reg .u64 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u32 %r10;
	.reg .u64 %r11;
	.reg .u64 %r12;
	.reg .u64 %r13;
	.reg .u32 %r14;
	.reg .u32 %r15;
	.reg .u32 %r16;
	.reg .pred %p17;
	.reg .u32 %r18;
	.reg .u64 %r19;
	.reg .u64 %r20;
	.reg .u64 %r21;
	.reg .u64 %r22;
	$BB_5_0002:				/* $LDWbegin_testShr */ 
		mov.u64 %r0, __cuda___cuda_local_var_28496_30_non_const_storage1208;
		mov.u32 %r1, %ctaid.x;
		mov.u32 %r2, %ntid.x;
		mul.lo.u32 %r3, %r1, %r2;
		mov.u32 %r4, %tid.x;
		add.u32 %r5, %r3, %r4;
		mul.lo.s32 %r6, %r5, 2;
		cvt.u64.u32 %r7, %r4;
		mul.wide.u32 %r8, %r4, 4;
		add.u64 %r9, %r0, %r8;
		st.shared.s32 [%r9 + 0], %r6;
		bar.sync 0;
		xor.b32 %r10, %r4, 1;
		cvt.u64.u32 %r11, %r10;
		mul.wide.u32 %r12, %r10, 4;
		add.u64 %r13, %r0, %r12;
		ld.shared.s32 %r14, [%r13 + 0];
		and.b32 %r15, %r5, 1;
		mov.u32 %r16, 0;
		setp.eq.s32 %p17, %r15, %r16;
		@%p17 bra $BB_5_0004;
	$BB_5_0003:
		mul.lo.s32 %r18, %r14, 19;
		bra.uni $BB_5_0005;
	$BB_5_0004:				/* $Lt_4_1282 */ 
		mul.lo.s32 %r18, %r14, 13;
	$BB_5_0005:				/* $Lt_4_1026 */ 
		ld.param.u64 %r19, [__cudaparm_testShr_A];
		cvt.s64.s32 %r20, %r5;
		mul.wide.s32 %r21, %r5, 4;
		add.u64 %r22, %r19, %r21;
		st.global.s32 [%r22 + 0], %r18;
		exit;
}
(0.012516) KernelPartitioningPass.cpp:596:  


(0.012734) KernelPartitioningPass.cpp:145:    Spill region size is 176
(0.012753) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.012774) KernelPartitioningPass.cpp:159:   block entry
(0.012782) KernelPartitioningPass.cpp:159:   block exit
(0.012788) KernelPartitioningPass.cpp:159:   block $BB_5_0002
(0.012805) KernelPartitioningPass.cpp:172:  barrier in block $BB_5_0002(instruction 11)
(0.012813) KernelPartitioningPass.cpp:159:   block $BB_5_0003
(0.012819) KernelPartitioningPass.cpp:159:   block $BB_5_0004
(0.012826) KernelPartitioningPass.cpp:159:   block $BB_5_0005
(0.012833) KernelPartitioningPass.cpp:159:   block $BB_5_0002_bar
(0.013076) KernelPartitioningPass.cpp:185:  identifying transition points
(0.013093) KernelPartitioningPass.cpp:199:   block $BB_5_0002
(0.013115) KernelPartitioningPass.cpp:199:   block $BB_5_0002_bar
(0.013139) KernelPartitioningPass.cpp:199:   block $BB_5_0003
(0.013153) KernelPartitioningPass.cpp:199:   block $BB_5_0004
(0.013166) KernelPartitioningPass.cpp:199:   block $BB_5_0005
(0.013188) KernelPartitioningPass.cpp:229:   block $BB_5_0002
(0.013208) KernelPartitioningPass.cpp:229:   block $BB_5_0002_bar
(0.013230) KernelPartitioningPass.cpp:229:   block $BB_5_0003
(0.013242) KernelPartitioningPass.cpp:229:   block $BB_5_0004
(0.013262) KernelPartitioningPass.cpp:229:   block $BB_5_0005
(0.013292) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bar
(0.013315) KernelPartitioningPass.cpp:360:    terminator->toString() = bar.sync 0
(0.013341) KernelPartitioningPass.cpp:549:  created exit in block '$BB_5_0002_exit' with code 5
(0.013357) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bra
(0.013368) KernelPartitioningPass.cpp:360:    terminator->toString() = @%p17 bra $BB_5_0004
(0.013387) KernelPartitioningPass.cpp:549:  created exit in block '$BB_5_0002_bar_exit' with code 2
(0.013408) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bra
(0.013426) KernelPartitioningPass.cpp:360:    terminator->toString() = bra.uni $BB_5_0005
(0.013439) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = mul
(0.013457) KernelPartitioningPass.cpp:360:    terminator->toString() = mul.lo.s32 %r18, %r14, 13
(0.013475) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.013495) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.013520) KernelPartitioningPass.cpp:549:  created exit in block '$BB_5_0005_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry testShr(.param  .u64 __cudaparm_testShr_A)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[176];
	.shared .align 4 .b8 __cuda___cuda_local_var_28496_30_non_const_storage1208[1024];

	.reg .u64 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u32 %r18;
	.reg .u32 %r14;
	.reg .u64 %r19;
	.reg .u64 %r20;
	.reg .u64 %r21;
	.reg .u64 %r22;
	.reg .u32 %r10;
	.reg .u64 %r11;
	.reg .u64 %r12;
	.reg .u64 %r13;
	.reg .u32 %r15;
	.reg .u32 %r16;
	.reg .pred %p17;
	.reg .u32 %r23;
	.reg .u32 %r24;
	.reg .u32 %r25;
	.reg .u32 %r26;
	.reg .u32 %r27;
	.reg .u32 %r28;
	.reg .u32 %r29;
	.reg .u32 %r30;
	.reg .u32 %r31;
	.reg .u32 %r33;
	.reg .u32 %r34;
	$BB_5_0002:				/* $LDWbegin_testShr */ 
		mov.u64 %r0, __cuda___cuda_local_var_28496_30_non_const_storage1208;
		mov.u32 %r1, %ctaid.x;
		mov.u32 %r2, %ntid.x;
		mul.lo.u32 %r3, %r1, %r2;
		mov.u32 %r4, %tid.x;
		add.u32 %r5, %r3, %r4;
		mul.lo.s32 %r6, %r5, 2;
		cvt.u64.u32 %r7, %r4;
		mul.wide.u32 %r8, %r4, 4;
		add.u64 %r9, %r0, %r8;
		st.shared.s32 [%r9 + 0], %r6;
		bra $BB_5_0002_exit;
	$BB_5_0002_bar:
		xor.b32 %r10, %r4, 1;
		cvt.u64.u32 %r11, %r10;
		mul.wide.u32 %r12, %r10, 4;
		add.u64 %r13, %r0, %r12;
		ld.shared.s32 %r14, [%r13 + 0];
		and.b32 %r15, %r5, 1;
		mov.u32 %r16, 0;
		setp.eq.s32 %p17, %r15, %r16;
		@%p17 bra $BB_5_0004;
	$BB_5_0003:
		mul.lo.s32 %r18, %r14, 19;
		bra.uni $BB_5_0005;
	$BB_5_0004:				/* $Lt_4_1282 */ 
		mul.lo.s32 %r18, %r14, 13;
	$BB_5_0005:				/* $Lt_4_1026 */ 
		ld.param.u64 %r19, [__cudaparm_testShr_A];
		cvt.s64.s32 %r20, %r5;
		mul.wide.s32 %r21, %r5, 4;
		add.u64 %r22, %r19, %r21;
		st.global.s32 [%r22 + 0], %r18;
		bra $BB_5_0005_exit;
	$BB_5_0002_entry:				/* entryId: 0 */ 
		bra $BB_5_0002;
	$BB_5_0002_bar_entry:				/* entryId: 1 */ 
		mov.s32 %r23, _Zocelot_spill_area;
		ld.local.u32 %r5, [%r23 + 40];
		ld.local.u32 %r4, [%r23 + 32];
		ld.local.u64 %r0, [%r23 + 0];
		bra $BB_5_0002_bar;
	$BB_5_0003_entry:				/* entryId: 2 */ 
		mov.s32 %r24, _Zocelot_spill_area;
		ld.local.u32 %r5, [%r24 + 40];
		ld.local.u32 %r14, [%r24 + 112];
		bra $BB_5_0003;
	$BB_5_0004_entry:				/* entryId: 3 */ 
		mov.s32 %r25, _Zocelot_spill_area;
		ld.local.u32 %r5, [%r25 + 40];
		ld.local.u32 %r14, [%r25 + 112];
		bra $BB_5_0004;
	$BB_5_0005_entry:				/* entryId: 4 */ 
		mov.s32 %r26, _Zocelot_spill_area;
		ld.local.u32 %r18, [%r26 + 144];
		ld.local.u32 %r5, [%r26 + 40];
		bra $BB_5_0005;
	$BB_5_0002_exit:				/* barrier handler */ 
		mov.s32 %r27, _Zocelot_spill_area;
		st.local.u64 [%r27 + 0], %r0;
		st.local.u32 [%r27 + 32], %r4;
		st.local.u32 [%r27 + 40], %r5;
		mov.u32 %r28, _Zocelot_resume_point;
		st.local.u32 [%r28 + 0], 1;
		mov.u32 %r28, _Zocelot_resume_status;
		st.local.u32 [%r28 + 0], 5;
		yield;
	$BB_5_0002_bar_exit:				/* divergent branch */ 
		mov.s32 %r29, _Zocelot_spill_area;
		st.local.u32 [%r29 + 112], %r14;
		st.local.u32 [%r29 + 40], %r5;
		selp.s32 %r30, 3, 2, %p17;
		mov.u32 %r31, _Zocelot_resume_point;
		st.local.u32 [%r31 + 0], %r30;
		mov.u32 %r31, _Zocelot_resume_status;
		st.local.u32 [%r31 + 0], 2;
		yield;
	$BB_5_0004_exit:
		mov.s32 %r33, _Zocelot_spill_area;
		st.local.u32 [%r33 + 40], %r5;
		st.local.u32 [%r33 + 144], %r18;
	$BB_5_0005_exit:				/* exit */ 
		mov.u32 %r34, _Zocelot_resume_status;
		st.local.u32 [%r34 + 0], 6;
		yield;
}
(0.014498) KernelPartitioningPass.cpp:593:  Run on kernel 'testShareConvergent'
/*
* Ocelot Version : 2.0.896
*/
.entry testShareConvergent(.param  .u64 __cudaparm_testShareConvergent_A)
{
	.shared .align 4 .b8 __cuda___cuda_local_var_28465_30_non_const_storage24[1024];

	.reg .u64 %r0;
	.reg .u32 %r1;
	.reg .u64 %r2;
	.reg .u64 %r3;
	.reg .u32 %r4;
	.reg .u64 %r5;
	.reg .u32 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u32 %r10;
	.reg .u32 %r11;
	.reg .u64 %r12;
	.reg .u64 %r13;
	$BB_2_0002:				/* $LDWbegin_testShareConvergent */ 
		mov.u64 %r0, __cuda___cuda_local_var_28465_30_non_const_storage24;
		cvt.s32.u32 %r1, %tid.x;
		cvt.s64.s32 %r2, %r1;
		mul.wide.s32 %r3, %r1, 4;
		mul.lo.s32 %r4, %r1, 2;
		add.u64 %r5, %r3, %r0;
		st.shared.s32 [%r5 + 0], %r4;
		bar.sync 0;
		xor.b32 %r6, %r1, 2;
		cvt.u64.u32 %r7, %r6;
		mul.wide.u32 %r8, %r6, 4;
		add.u64 %r9, %r0, %r8;
		ld.shared.u32 %r10, [%r9 + 0];
		add.u32 %r11, %r1, %r10;
		ld.param.u64 %r12, [__cudaparm_testShareConvergent_A];
		add.u64 %r13, %r12, %r3;
		st.global.s32 [%r13 + 0], %r11;
		exit;
}
(0.014690) KernelPartitioningPass.cpp:596:  


(0.014849) KernelPartitioningPass.cpp:145:    Spill region size is 104
(0.014869) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.014878) KernelPartitioningPass.cpp:159:   block entry
(0.014885) KernelPartitioningPass.cpp:159:   block exit
(0.014894) KernelPartitioningPass.cpp:159:   block $BB_2_0002
(0.014908) KernelPartitioningPass.cpp:172:  barrier in block $BB_2_0002(instruction 7)
(0.014918) KernelPartitioningPass.cpp:159:   block $BB_2_0002_bar
(0.015063) KernelPartitioningPass.cpp:185:  identifying transition points
(0.015078) KernelPartitioningPass.cpp:199:   block $BB_2_0002
(0.015092) KernelPartitioningPass.cpp:199:   block $BB_2_0002_bar
(0.015112) KernelPartitioningPass.cpp:229:   block $BB_2_0002
(0.015133) KernelPartitioningPass.cpp:229:   block $BB_2_0002_bar
(0.015168) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bar
(0.015185) KernelPartitioningPass.cpp:360:    terminator->toString() = bar.sync 0
(0.015201) KernelPartitioningPass.cpp:549:  created exit in block '$BB_2_0002_exit' with code 5
(0.015220) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.015237) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.015254) KernelPartitioningPass.cpp:549:  created exit in block '$BB_2_0002_bar_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry testShareConvergent(.param  .u64 __cudaparm_testShareConvergent_A)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[104];
	.shared .align 4 .b8 __cuda___cuda_local_var_28465_30_non_const_storage24[1024];

	.reg .u64 %r0;
	.reg .u32 %r1;
	.reg .u64 %r2;
	.reg .u64 %r3;
	.reg .u32 %r4;
	.reg .u64 %r5;
	.reg .u32 %r6;
	.reg .u64 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u32 %r10;
	.reg .u32 %r11;
	.reg .u64 %r12;
	.reg .u64 %r13;
	.reg .u32 %r14;
	.reg .u32 %r15;
	.reg .u32 %r16;
	.reg .u32 %r17;
	$BB_2_0002:				/* $LDWbegin_testShareConvergent */ 
		mov.u64 %r0, __cuda___cuda_local_var_28465_30_non_const_storage24;
		cvt.s32.u32 %r1, %tid.x;
		cvt.s64.s32 %r2, %r1;
		mul.wide.s32 %r3, %r1, 4;
		mul.lo.s32 %r4, %r1, 2;
		add.u64 %r5, %r3, %r0;
		st.shared.s32 [%r5 + 0], %r4;
		bra $BB_2_0002_exit;
	$BB_2_0002_bar:
		xor.b32 %r6, %r1, 2;
		cvt.u64.u32 %r7, %r6;
		mul.wide.u32 %r8, %r6, 4;
		add.u64 %r9, %r0, %r8;
		ld.shared.u32 %r10, [%r9 + 0];
		add.u32 %r11, %r1, %r10;
		ld.param.u64 %r12, [__cudaparm_testShareConvergent_A];
		add.u64 %r13, %r12, %r3;
		st.global.s32 [%r13 + 0], %r11;
		bra $BB_2_0002_bar_exit;
	$BB_2_0002_entry:				/* entryId: 0 */ 
		bra $BB_2_0002;
	$BB_2_0002_bar_entry:				/* entryId: 1 */ 
		mov.s32 %r14, _Zocelot_spill_area;
		ld.local.u64 %r3, [%r14 + 24];
		ld.local.u32 %r1, [%r14 + 8];
		ld.local.u64 %r0, [%r14 + 0];
		bra $BB_2_0002_bar;
	$BB_2_0002_exit:				/* barrier handler */ 
		mov.s32 %r15, _Zocelot_spill_area;
		st.local.u64 [%r15 + 0], %r0;
		st.local.u32 [%r15 + 8], %r1;
		st.local.u64 [%r15 + 24], %r3;
		mov.u32 %r16, _Zocelot_resume_point;
		st.local.u32 [%r16 + 0], 1;
		mov.u32 %r16, _Zocelot_resume_status;
		st.local.u32 [%r16 + 0], 5;
		yield;
	$BB_2_0002_bar_exit:				/* exit */ 
		mov.u32 %r17, _Zocelot_resume_status;
		st.local.u32 [%r17 + 0], 6;
		yield;
}
(0.015770) KernelPartitioningPass.cpp:593:  Run on kernel 'sequence'
/*
* Ocelot Version : 2.0.896
*/
.entry sequence(.param  .u64 __cudaparm_sequence_A,
		.param  .s32 __cudaparm_sequence_N)
{

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .pred %p6;
	.reg .u32 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u64 %r10;
	.reg .u64 %r11;
	$BB_1_0002:				/* $LDWbegin_sequence */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %tid.x;
		add.u32 %r4, %r3, %r2;
		ld.param.s32 %r5, [__cudaparm_sequence_N];
		setp.le.s32 %p6, %r5, %r4;
		@%p6 bra $BB_1_0004;
	$BB_1_0003:
		mul.lo.s32 %r7, %r4, 2;
		ld.param.u64 %r8, [__cudaparm_sequence_A];
		cvt.s64.s32 %r9, %r4;
		mul.wide.s32 %r10, %r4, 4;
		add.u64 %r11, %r8, %r10;
		st.global.s32 [%r11 + 0], %r7;
	$BB_1_0004:				/* $Lt_0_1026 */ 
		exit;
}
(0.015921) KernelPartitioningPass.cpp:596:  


(0.016063) KernelPartitioningPass.cpp:145:    Spill region size is 88
(0.016083) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.016091) KernelPartitioningPass.cpp:159:   block entry
(0.016099) KernelPartitioningPass.cpp:159:   block exit
(0.016106) KernelPartitioningPass.cpp:159:   block $BB_1_0002
(0.016113) KernelPartitioningPass.cpp:159:   block $BB_1_0003
(0.016121) KernelPartitioningPass.cpp:159:   block $BB_1_0004
(0.016265) KernelPartitioningPass.cpp:185:  identifying transition points
(0.016280) KernelPartitioningPass.cpp:199:   block $BB_1_0002
(0.016294) KernelPartitioningPass.cpp:199:   block $BB_1_0003
(0.016307) KernelPartitioningPass.cpp:199:   block $BB_1_0004
(0.016319) KernelPartitioningPass.cpp:229:   block $BB_1_0002
(0.016331) KernelPartitioningPass.cpp:229:   block $BB_1_0003
(0.016341) KernelPartitioningPass.cpp:229:   block $BB_1_0004
(0.016360) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bra
(0.016373) KernelPartitioningPass.cpp:360:    terminator->toString() = @%p6 bra $BB_1_0004
(0.016390) KernelPartitioningPass.cpp:549:  created exit in block '$BB_1_0002_exit' with code 2
(0.016398) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = st
(0.016413) KernelPartitioningPass.cpp:360:    terminator->toString() = st.global.s32 [%r11 + 0], %r7
(0.016421) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.016430) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.016443) KernelPartitioningPass.cpp:549:  created exit in block '$BB_1_0004_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry sequence(.param  .u64 __cudaparm_sequence_A,
		.param  .s32 __cudaparm_sequence_N)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[88];

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .pred %p6;
	.reg .u32 %r7;
	.reg .u64 %r8;
	.reg .u64 %r9;
	.reg .u64 %r10;
	.reg .u64 %r11;
	.reg .u32 %r12;
	.reg .u32 %r13;
	.reg .u32 %r14;
	.reg .u32 %r15;
	.reg .u32 %r16;
	$BB_1_0002:				/* $LDWbegin_sequence */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %tid.x;
		add.u32 %r4, %r3, %r2;
		ld.param.s32 %r5, [__cudaparm_sequence_N];
		setp.le.s32 %p6, %r5, %r4;
		@%p6 bra $BB_1_0004;
	$BB_1_0003:
		mul.lo.s32 %r7, %r4, 2;
		ld.param.u64 %r8, [__cudaparm_sequence_A];
		cvt.s64.s32 %r9, %r4;
		mul.wide.s32 %r10, %r4, 4;
		add.u64 %r11, %r8, %r10;
		st.global.s32 [%r11 + 0], %r7;
	$BB_1_0004:				/* $Lt_0_1026 */ 
		bra $BB_1_0004_exit;
	$BB_1_0004_exit:				/* exit */ 
		mov.u32 %r16, _Zocelot_resume_status;
		st.local.u32 [%r16 + 0], 6;
		yield;
	$BB_1_0002_entry:				/* entryId: 0 */ 
		bra $BB_1_0002;
	$BB_1_0003_entry:				/* entryId: 1 */ 
		mov.s32 %r12, _Zocelot_spill_area;
		ld.local.u32 %r4, [%r12 + 32];
		bra $BB_1_0003;
	$BB_1_0004_entry:				/* entryId: 2 */ 
		bra $BB_1_0004;
	$BB_1_0002_exit:				/* divergent branch */ 
		mov.s32 %r13, _Zocelot_spill_area;
		st.local.u32 [%r13 + 32], %r4;
		selp.s32 %r14, 2, 1, %p6;
		mov.u32 %r15, _Zocelot_resume_point;
		st.local.u32 [%r15 + 0], %r14;
		mov.u32 %r15, _Zocelot_resume_status;
		st.local.u32 [%r15 + 0], 2;
		yield;
	$BB_1_0003_exit:
}
(0.016956) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 1, 1
(0.016966) LLVMDynamicExecutionManager.cpp:61:     block dim: 4, 1, 1
(0.016974) LLVMDynamicExecutionManager.cpp:62:     entry id: 262144
(0.016982) LLVMDynamicExecutionManager.cpp:63:     local memory size: 96 bytes
(0.016989) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 0 bytes 
(0.016997) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.017004) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.017016) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 96, total threads: 4, shared memory size: 0
(0.017028) LLVMDynamicExecutive.cpp:207:  execute()
(0.017039) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 262144
(0.017046) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.017056) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 262144
(0.017063) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 262144, ws: 2)
(0.017071) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.017078) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 262144, warpsize: 2)
(0.017086) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager
(0.018787) LLVMDynamicTranslationCache.cpp:1037: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_sequence( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0;
	%rt3 = load i32* %rt2;
	%r1 = bitcast i32 %rt3 to i32;
	%r2 = mul i32 %r0, %r1;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt5 = load i32* %rt4;
	%r3 = bitcast i32 %rt5 to i32;
	%r4 = add i32 %r3, %r2;
	%rt7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt8 = load i8** %rt7;
	%rt6 = getelementptr i8* %rt8, i32 8;
	%rt9 = bitcast i8* %rt6 to i32*;
	%r5 = load i32* %rt9, align 4;
	%r6 = icmp sle i32 %r5, %r4;
	br i1 %r6, label %$BB_1_0004, label %$BB_1_0003;
$BB_1_0003:
	%r7 = phi i32 [ %r4, %$BB_1_0002 ], [ %r15, %$BB_1_0003_entry ];
	%r8 = mul i32 %r7, 2;
	%rt10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt11 = load i8** %rt10;
	%rt12 = bitcast i8* %rt11 to i64*;
	%r9 = load i64* %rt12, align 8;
	%r10 = sext i32 %r7 to i64;
	%rt13 = sext i32 %r7 to i64;
	%r11 = mul i64 %rt13, 4;
	%r12 = add i64 %r9, %r11;
	%rt14 = inttoptr i64 %r12 to i32*;
	store i32 %r8, i32* %rt14, align 4;
	br label %$BB_1_0004;
$BB_1_0004:
	br i1 1, label %$BB_1_0004_exit, label %exit;
$BB_1_0004_exit:
	%r13 = bitcast i32 0 to i32;
	%rt15 = zext i32 %r13 to i64;
	%rt16 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt17 = load i8** %rt16;
	%rt18 = ptrtoint i8* %rt17 to i64;
	%rt19 = add i64 %rt15, %rt18;
	%rt20 = inttoptr i64 %rt19 to i32*;
	store i32 6, i32* %rt20, align 4;
	br label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0003_entry:
	%r14 = bitcast i32 8 to i32;
	%rt21 = zext i32 %r14 to i64;
	%rt22 = add i64 %rt21, 32;
	%rt23 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt24 = load i8** %rt23;
	%rt25 = ptrtoint i8* %rt24 to i64;
	%rt26 = add i64 %rt22, %rt25;
	%rt27 = inttoptr i64 %rt26 to i32*;
	%r15 = load i32* %rt27, align 4;
	br label %$BB_1_0003;
$BB_1_0004_entry:
	br label %$BB_1_0004;
$BB_1_0002_exit:
	%r16 = phi i32 [ %r4, %$BB_1_0002 ];
	%r17 = phi i1 [ %r6, %$BB_1_0002 ];
	%r18 = bitcast i32 8 to i32;
	%rt28 = zext i32 %r18 to i64;
	%rt29 = add i64 %rt28, 32;
	%rt30 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt31 = load i8** %rt30;
	%rt32 = ptrtoint i8* %rt31 to i64;
	%rt33 = add i64 %rt29, %rt32;
	%rt34 = inttoptr i64 %rt33 to i32*;
	store i32 %r16, i32* %rt34, align 4;
	%r19 = select i1 %r17, i32 2, i32 1;
	%r20 = bitcast i32 4 to i32;
	%rt35 = zext i32 %r20 to i64;
	%rt36 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt37 = load i8** %rt36;
	%rt38 = ptrtoint i8* %rt37 to i64;
	%rt39 = add i64 %rt35, %rt38;
	%rt40 = inttoptr i64 %rt39 to i32*;
	store i32 %r19, i32* %rt40, align 4;
	%r21 = bitcast i32 0 to i32;
	%rt41 = zext i32 %r21 to i64;
	%rt42 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt43 = load i8** %rt42;
	%rt44 = ptrtoint i8* %rt43 to i64;
	%rt45 = add i64 %rt41, %rt44;
	%rt46 = inttoptr i64 %rt45 to i32*;
	store i32 2, i32* %rt46, align 4;
	br label %exit;
$BB_1_0003_exit:
	ret void;
exit:
	ret void;

}

(0.021355) LLVMUniformVectorization.cpp:222:  Vectorization: _Z_ocelotTranslated_sequence_opt3_ws2
(0.021366) LLVMUniformVectorization.cpp:226:  Breadth first traversal:
(0.021380) LLVMUniformVectorization.cpp:229:  Creating prolog block to replace scheduler
(0.021387) LLVMUniformVectorization.cpp:232:  Loading thread-local values
(0.021393) LLVMUniformVectorization.cpp:383:  loadThreadLocalArguments
(0.021434) LLVMUniformVectorization.cpp:239:  Adding interleaved and replicated instructions:
(0.021440) LLVMUniformVectorization.cpp:449:  AddInterleavedInstructions()
(0.021444) LLVMUniformVectorization.cpp:454:    traversal contains:
(0.021449) LLVMUniformVectorization.cpp:459:    - $BB_1_0002
(0.021457) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_ws_2]
(0.021463) LLVMUniformVectorization.cpp:459:    - $BB_1_0004
(0.021469) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0004_ws_2]
(0.021488) LLVMUniformVectorization.cpp:459:    - $BB_1_0003
(0.021494) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0003_ws_2]
(0.021500) LLVMUniformVectorization.cpp:459:    - $BB_1_0004_exit
(0.021506) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0004_exit_ws_2]
(0.021511) LLVMUniformVectorization.cpp:459:    - exit
(0.021518) LLVMUniformVectorization.cpp:472:      [ constructed as exit_ws_2]
(0.021523) LLVMUniformVectorization.cpp:459:    - $BB_1_0002_entry
(0.021529) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_entry_ws_2]
(0.021534) LLVMUniformVectorization.cpp:459:    - $BB_1_0003_entry
(0.021540) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0003_entry_ws_2]
(0.021545) LLVMUniformVectorization.cpp:459:    - $BB_1_0004_entry
(0.021551) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0004_entry_ws_2]
(0.021556) LLVMUniformVectorization.cpp:459:    - $BB_1_0002_exit
(0.021562) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_exit_ws_2]
(0.021568) LLVMUniformVectorization.cpp:459:    - $BB_1_0003_exit
(0.021574) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0003_exit_ws_2]
(0.021894) LLVMUniformVectorization.cpp:242:  Updating data dependencies among replicated instructions
(0.021924) LLVMUniformVectorization.cpp:245:  Updating control flow among warp-synchronous replicated blocks
(0.021947) LLVMUniformVectorization.cpp:248:  Vectorizing replicated instruction bundles
(0.021991) LLVMUniformVectorization.cpp:255:  Removing superfluous scalar blocks
(0.022023) LLVMUniformVectorization.cpp:258:  Creating scheduler block
(0.022029) LLVMUniformVectorization.cpp:1373: Updating subkernel entry points
(0.022040) LLVMUniformVectorization.cpp:1399: There are 3 entry points
(0.022045) LLVMUniformVectorization.cpp:1344: seeking label BB_1_0002_entry_ws
(0.022050) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.022055) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_ws_2
(0.022059) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0004_ws_2
(0.022063) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0003_ws_2
(0.022068) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0004_exit_ws_2
(0.022072) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.022077) LLVMUniformVectorization.cpp:1344: seeking label BB_1_0003_entry_ws
(0.022081) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.022085) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_ws_2
(0.022089) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0004_ws_2
(0.022093) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0003_ws_2
(0.022097) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0004_exit_ws_2
(0.022101) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.022106) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_entry_ws_2
(0.022111) LLVMUniformVectorization.cpp:1344: seeking label BB_1_0004_entry_ws
(0.022115) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.022119) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_ws_2
(0.022123) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0004_ws_2
(0.022127) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0003_ws_2
(0.022131) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0004_exit_ws_2
(0.022135) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.022139) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0002_entry_ws_2
(0.022143) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_1_0003_entry_ws_2
(0.022148) LLVMUniformVectorization.cpp:1414: Created switch with 3 cases
(0.022153) LLVMUniformVectorization.cpp:1421: adding successor 0 - $BB_1_0002_entry_ws_2
(0.022158) LLVMUniformVectorization.cpp:1421: addin
define internal void @_Z_ocelotTranslated_sequence_opt3_ws2(%LLVMContext* %__ctaContext) nounwind align 1 {
WarpSynchronousEntry:
  %ptrLocalMemPtr = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 4
  %localMemPtr.0 = load i8** %ptrLocalMemPtr, align 8
  %ptr = getelementptr i8* %localMemPtr.0, i64 4
  %ptrEntryPoint = bitcast i8* %ptr to i32*
  %warpEntryId = load i32* %ptrEntryPoint, align 4
  %warpEntryPoint = and i32 %warpEntryId, 65535
  switch i32 %warpEntryPoint, label %"$BB_1_0002_entry_ws_2" [
    i32 2, label %"$BB_1_0004_exit_ws_2"
    i32 1, label %"$BB_1_0003_entry_ws_2"
  ]

"$BB_1_0003_ws_2":                                ; preds = %"$BB_1_0002_entry_ws_2", %"$BB_1_0003_entry_ws_2"
  %rt10.t1.pre-phi = phi i8** [ %rt7.t1, %"$BB_1_0002_entry_ws_2" ], [ %rt10.t1.pre, %"$BB_1_0003_entry_ws_2" ]
  %rt10.t0.pre-phi = phi i8** [ %rt7.t0, %"$BB_1_0002_entry_ws_2" ], [ %rt10.t0.pre, %"$BB_1_0003_entry_ws_2" ]
  %r7.t0 = phi i32 [ %r4.t0, %"$BB_1_0002_entry_ws_2" ], [ %r15.t0, %"$BB_1_0003_entry_ws_2" ]
  %r7.t1 = phi i32 [ %r4.t1, %"$BB_1_0002_entry_ws_2" ], [ %r15.t1, %"$BB_1_0003_entry_ws_2" ]
  %r8.t0 = shl i32 %r7.t0, 1
  %r8.t1 = shl i32 %r7.t1, 1
  %rt11.t0 = load i8** %rt10.t0.pre-phi, align 8
  %rt11.t1 = load i8** %rt10.t1.pre-phi, align 8
  %rt12.t0 = bitcast i8* %rt11.t0 to i64*
  %rt12.t1 = bitcast i8* %rt11.t1 to i64*
  %r9.t0 = load i64* %rt12.t0, align 8
  %r9.t1 = load i64* %rt12.t1, align 8
  %rt13.t0 = sext i32 %r7.t0 to i64
  %rt13.t1 = sext i32 %r7.t1 to i64
  %r11.t0 = mul i64 %rt13.t0, 4
  %r11.t1 = mul i64 %rt13.t1, 4
  %r12.t0 = add i64 %r9.t0, %r11.t0
  %r12.t1 = add i64 %r9.t1, %r11.t1
  %rt14.t0 = inttoptr i64 %r12.t0 to i32*
  %rt14.t1 = inttoptr i64 %r12.t1 to i32*
  store i32 %r8.t0, i32* %rt14.t0, align 4
  store i32 %r8.t1, i32* %rt14.t1, align 4
  br label %"$BB_1_0004_exit_ws_2"

"$BB_1_0004_exit_ws_2":                           ; preds = %WarpSynchronousEntry, %"$BB_1_0003_ws_2", %"$BB_1_0002_entry_ws_2"
  %rt16.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 4
  %rt17.t0 = load i8** %ptrLocalMemPtr, align 8
  %rt17.t1 = load i8** %rt16.t1, align 8
  %rt20.t0 = bitcast i8* %rt17.t0 to i32*
  %rt20.t1 = bitcast i8* %rt17.t1 to i32*
  store i32 6, i32* %rt20.t0, align 4
  store i32 6, i32* %rt20.t1, align 4
  br label %exit_ws_2

exit_ws_2:                                        ; preds = %"$BB_1_0002_exit_ws_2", %"$BB_1_0004_exit_ws_2"
  ret void

"$BB_1_0002_entry_ws_2":                          ; preds = %WarpSynchronousEntry
  %rt0.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 2, i32 0
  %rt0.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 2, i32 0
  %rt1.t0 = load i32* %rt0.t0, align 4
  %rt1.t1 = load i32* %rt0.t1, align 4
  %rt2.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 1, i32 0
  %rt2.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 1, i32 0
  %rt3.t0 = load i32* %rt2.t0, align 4
  %rt3.t1 = load i32* %rt2.t1, align 4
  %r2.t0 = mul i32 %rt3.t0, %rt1.t0
  %r2.t1 = mul i32 %rt3.t1, %rt1.t1
  %rt4.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 0, i32 0
  %rt4.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 0, i32 0
  %rt5.t0 = load i32* %rt4.t0, align 4
  %rt5.t1 = load i32* %rt4.t1, align 4
  %r4.t0 = add i32 %rt5.t0, %r2.t0
  %r4.t1 = add i32 %rt5.t1, %r2.t1
  %rt7.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 8
  %rt7.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 8
  %rt8.t0 = load i8** %rt7.t0, align 8
  %rt8.t1 = load i8** %rt7.t1, align 8
  %rt6.t0 = getelementptr i8* %rt8.t0, i64 8
  %rt6.t1 = getelementptr i8* %rt8.t1, i64 8
  %rt9.t0 = bitcast i8* %rt6.t0 to i32*
  %rt9.t1 = bitcast i8* %rt6.t1 to i32*
  %r5.t0 = load i32* %rt9.t0, align 4
  %r5.t1 = load i32* %rt9.t1, align 4
  %r6.t0 = icmp sle i32 %r5.t0, %r4.t0
  %r6.t1 = icmp sle i32 %r5.t1, %r4.t1
  %condZ = zext i1 %r6.t0 to i32
  %cmpws = zext i1 %r6.t1 to i32
  %cmpws5 = add i32 %cmpws, %condZ
  switch i32 %cmpws5, label %"$BB_1_0002_exit_ws_2" [
    i32 2, label %"$BB_1_0004_exit_ws_2"
    i32 0, label %"$BB_1_0003_ws_2"
  ]

"$BB_1_0003_entry_ws_2":                          ; preds = %WarpSynchronousEntry
  %rt23.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 4
  %rt24.t0 = load i8** %ptrLocalMemPtr, align 8
  %rt24.t1 = load i8** %rt23.t1, align 8
  %rt25.t0 = ptrtoint i8* %rt24.t0 to i64
  %rt25.t1 = ptrtoint i8* %rt24.t1 to i64
  %rt26.t0 = add i64 %rt25.t0, 40
  %rt26.t1 = add i64 %rt25.t1, 40
  %rt27.t0 = inttoptr i64 %rt26.t0 to i32*
  %rt27.t1 = inttoptr i64 %rt26.t1 to i32*
  %r15.t0 = load i32* %rt27.t0, align 4
  %r15.t1 = load i32* %rt27.t1, align 4
  %rt10.t0.pre = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 8
  %rt10.t1.pre = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 8
  br label %"$BB_1_0003_ws_2"

"$BB_1_0002_exit_ws_2":                           ; preds = %"$BB_1_0002_entry_ws_2"
  %rt30.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 4
  %rt31.t0 = load i8** %ptrLocalMemPtr, align 8
  %rt31.t1 = load i8** %rt30.t1, align 8
  %rt32.t0 = ptrtoint i8* %rt31.t0 to i64
  %rt32.t1 = ptrtoint i8* %rt31.t1 to i64
  %rt33.t0 = add i64 %rt32.t0, 40
  %rt33.t1 = add i64 %rt32.t1, 40
  %rt34.t0 = inttoptr i64 %rt33.t0 to i32*
  %rt34.t1 = inttoptr i64 %rt33.t1 to i32*
  store i32 %r4.t0, i32* %rt34.t0, align 4
  store i32 %r4.t1, i32* %rt34.t1, align 4
  %r19.t0 = select i1 %r6.t0, i32 2, i32 1
  %r19.t1 = select i1 %r6.t1, i32 2, i32 1
  %rt37.t0 = load i8** %ptrLocalMemPtr, align 8
  %rt37.t1 = load i8** %rt30.t1, align 8
  %rt38.t0 = ptrtoint i8* %rt37.t0 to i64
  %rt38.t1 = ptrtoint i8* %rt37.t1 to i64
  %rt39.t0 = add i64 %rt38.t0, 4
  %rt39.t1 = add i64 %rt38.t1, 4
  %rt40.t0 = inttoptr i64 %rt39.t0 to i32*
  %rt40.t1 = inttoptr i64 %rt39.t1 to i32*
  store i32 %r19.t0, i32* %rt40.t0, align 4
  store i32 %r19.t1, i32* %rt40.t1, align 4
  %rt43.t0 = load i8** %ptrLocalMemPtr, align 8
  %rt43.t1 = load i8** %rt30.t1, align 8
  %rt46.t0 = bitcast i8* %rt43.t0 to i32*
  %rt46.t1 = bitcast i8* %rt43.t1 to i32*
  store i32 2, i32* %rt46.t0, align 4
  store i32 2, i32* %rt46.t1, align 4
  br label %exit_ws_2
}


define internal void @_Z_ocelotTranslated_sequence_opt3_ws2(%LLVMContext* %__ctaContext) nounwind align 1 {
WarpSynchronousEntry:
  %ptrLocalMemPtr = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 4
  %localMemPtr.0 = load i8** %ptrLocalMemPtr, align 8
  %ptr = getelementptr i8* %localMemPtr.0, i64 4
  %ptrEntryPoint = bitcast i8* %ptr to i32*
  %warpEntryId = load i32* %ptrEntryPoint, align 4
  %warpEntryPoint = and i32 %warpEntryId, 65535
  switch i32 %warpEntryPoint, label %"$BB_1_0002_entry_ws_2" [
    i32 2, label %"$BB_1_0004_exit_ws_2"
    i32 1, label %"$BB_1_0003_entry_ws_2"
  ]

"$BB_1_0003_ws_2":                                ; preds = %"$BB_1_0002_entry_ws_2", %"$BB_1_0003_entry_ws_2"
  %rt10.t1.pre-phi = phi i8** [ %rt7.t1, %"$BB_1_0002_entry_ws_2" ], [ %rt10.t1.pre, %"$BB_1_0003_entry_ws_2" ]
  %rt10.t0.pre-phi = phi i8** [ %rt7.t0, %"$BB_1_0002_entry_ws_2" ], [ %rt10.t0.pre, %"$BB_1_0003_entry_ws_2" ]
  %r7.t0 = phi i32 [ %r4.t0, %"$BB_1_0002_entry_ws_2" ], [ %r15.t0, %"$BB_1_0003_entry_ws_2" ]
  %r7.t1 = phi i32 [ %r4.t1, %"$BB_1_0002_entry_ws_2" ], [ %r15.t1, %"$BB_1_0003_entry_ws_2" ]
  %r8.t0 = shl i32 %r7.t0, 1
  %r8.t1 = shl i32 %r7.t1, 1
  %rt11.t0 = load i8** %rt10.t0.pre-phi, align 8
  %rt11.t1 = load i8** %rt10.t1.pre-phi, align 8
  %rt12.t0 = bitcast i8* %rt11.t0 to i64*
  %rt12.t1 = bitcast i8* %rt11.t1 to i64*
  %r9.t0 = load i64* %rt12.t0, align 8
  %r9.t1 = load i64* %rt12.t1, align 8
  %rt13.t0 = sext i32 %r7.t0 to i64
  %rt13.t1 = sext i32 %r7.t1 to i64
  %r11.t0 = mul i64 %rt13.t0, 4
  %r11.t1 = mul i64 %rt13.t1, 4
  %r12.t0 = add i64 %r9.t0, %r11.t0
  %r12.t1 = add i64 %r9.t1, %r11.t1
  %rt14.t0 = inttoptr i64 %r12.t0 to i32*
  %rt14.t1 = inttoptr i64 %r12.t1 to i32*
  store i32 %r8.t0, i32* %rt14.t0, align 4
  store i32 %r8.t1, i32* %rt14.t1, align 4
  br label %"$BB_1_0004_exit_ws_2"

"$BB_1_0004_exit_ws_2":                           ; preds = %WarpSynchronousEntry, %"$BB_1_0003_ws_2", %"$BB_1_0002_entry_ws_2"
  %rt16.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 4
  %sunkaddr = ptrtoint %LLVMContext* %__ctaContext to i64
  %sunkaddr6 = add i64 %sunkaddr, 48
  %sunkaddr7 = inttoptr i64 %sunkaddr6 to i8**
  %rt17.t0 = load i8** %sunkaddr7, align 8
  %rt17.t1 = load i8** %rt16.t1, align 8
  %rt20.t0 = bitcast i8* %rt17.t0 to i32*
  %rt20.t1 = bitcast i8* %rt17.t1 to i32*
  store i32 6, i32* %rt20.t0, align 4
  store i32 6, i32* %rt20.t1, align 4
  br label %exit_ws_2

exit_ws_2:                                        ; preds = %"$BB_1_0002_exit_ws_2", %"$BB_1_0004_exit_ws_2"
  ret void

"$BB_1_0002_entry_ws_2":                          ; preds = %WarpSynchronousEntry
  %rt0.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 2, i32 0
  %rt0.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 2, i32 0
  %rt1.t0 = load i32* %rt0.t0, align 4
  %rt1.t1 = load i32* %rt0.t1, align 4
  %rt2.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 1, i32 0
  %rt2.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 1, i32 0
  %rt3.t0 = load i32* %rt2.t0, align 4
  %rt3.t1 = load i32* %rt2.t1, align 4
  %r2.t0 = mul i32 %rt3.t0, %rt1.t0
  %r2.t1 = mul i32 %rt3.t1, %rt1.t1
  %rt4.t08 = bitcast %LLVMContext* %__ctaContext to i32*
  %rt4.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 0, i32 0
  %rt5.t0 = load i32* %rt4.t08, align 4
  %rt5.t1 = load i32* %rt4.t1, align 4
  %r4.t0 = add i32 %rt5.t0, %r2.t0
  %r4.t1 = add i32 %rt5.t1, %r2.t1
  %rt7.t0 = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 8
  %rt7.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 8
  %rt8.t0 = load i8** %rt7.t0, align 8
  %rt8.t1 = load i8** %rt7.t1, align 8
  %rt6.t0 = getelementptr i8* %rt8.t0, i64 8
  %rt6.t1 = getelementptr i8* %rt8.t1, i64 8
  %rt9.t0 = bitcast i8* %rt6.t0 to i32*
  %rt9.t1 = bitcast i8* %rt6.t1 to i32*
  %r5.t0 = load i32* %rt9.t0, align 4
  %r5.t1 = load i32* %rt9.t1, align 4
  %r6.t0 = icmp sle i32 %r5.t0, %r4.t0
  %r6.t1 = icmp sle i32 %r5.t1, %r4.t1
  %condZ = zext i1 %r6.t0 to i32
  %cmpws = zext i1 %r6.t1 to i32
  %cmpws5 = add i32 %cmpws, %condZ
  switch i32 %cmpws5, label %"$BB_1_0002_exit_ws_2" [
    i32 2, label %"$BB_1_0004_exit_ws_2"
    i32 0, label %"$BB_1_0003_ws_2"
  ]

"$BB_1_0003_entry_ws_2":                          ; preds = %WarpSynchronousEntry
  %rt23.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 4
  %sunkaddr9 = ptrtoint %LLVMContext* %__ctaContext to i64
  %sunkaddr10 = add i64 %sunkaddr9, 48
  %sunkaddr11 = inttoptr i64 %sunkaddr10 to i8**
  %rt24.t0 = load i8** %sunkaddr11, align 8
  %rt24.t1 = load i8** %rt23.t1, align 8
  %rt25.t0 = ptrtoint i8* %rt24.t0 to i64
  %rt25.t1 = ptrtoint i8* %rt24.t1 to i64
  %rt26.t0 = add i64 %rt25.t0, 40
  %rt26.t1 = add i64 %rt25.t1, 40
  %rt27.t0 = inttoptr i64 %rt26.t0 to i32*
  %rt27.t1 = inttoptr i64 %rt26.t1 to i32*
  %r15.t0 = load i32* %rt27.t0, align 4
  %r15.t1 = load i32* %rt27.t1, align 4
  %rt10.t0.pre = getelementptr %LLVMContext* %__ctaContext, i64 0, i32 8
  %rt10.t1.pre = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 8
  br label %"$BB_1_0003_ws_2"

"$BB_1_0002_exit_ws_2":                           ; preds = %"$BB_1_0002_entry_ws_2"
  %0 = icmp sle i32 %r5.t1, %r4.t1
  %1 = icmp sle i32 %r5.t0, %r4.t0
  %rt30.t1 = getelementptr %LLVMContext* %__ctaContext, i64 1, i32 4
  %sunkaddr12 = ptrtoint %LLVMContext* %__ctaContext to i64
  %sunkaddr13 = add i64 %sunkaddr12, 48
  %sunkaddr14 = inttoptr i64 %sunkaddr13 to i8**
  %rt31.t0 = load i8** %sunkaddr14, align 8
  %rt31.t1 = load i8** %rt30.t1, align 8
  %rt32.t0 = ptrtoint i8* %rt31.t0 to i64
  %rt32.t1 = ptrtoint i8* %rt31.t1 to i64
  %rt33.t0 = add i64 %rt32.t0, 40
  %rt33.t1 = add i64 %rt32.t1, 40
  %rt34.t0 = inttoptr i64 %rt33.t0 to i32*
  %rt34.t1 = inttoptr i64 %rt33.t1 to i32*
  store i32 %r4.t0, i32* %rt34.t0, align 4
  store i32 %r4.t1, i32* %rt34.t1, align 4
  %r19.t0 = select i1 %1, i32 2, i32 1
  %r19.t1 = select i1 %0, i32 2, i32 1
  %rt37.t0 = load i8** %sunkaddr14, align 8
  %rt37.t1 = load i8** %rt30.t1, align 8
  %rt38.t0 = ptrtoint i8* %rt37.t0 to i64
  %rt38.t1 = ptrtoint i8* %rt37.t1 to i64
  %rt39.t0 = add i64 %rt38.t0, 4
  %rt39.t1 = add i64 %rt38.t1, 4
  %rt40.t0 = inttoptr i64 %rt39.t0 to i32*
  %rt40.t1 = inttoptr i64 %rt39.t1 to i32*
  store i32 %r19.t0, i32* %rt40.t0, align 4
  store i32 %r19.t1, i32* %rt40.t1, align 4
  %rt43.t0 = load i8** %sunkaddr14, align 8
  %rt43.t1 = load i8** %rt30.t1, align 8
  %rt46.t0 = bitcast i8* %rt43.t0 to i32*
  %rt46.t1 = bitcast i8* %rt43.t1 to i32*
  store i32 2, i32* %rt46.t0, align 4
  store i32 2, i32* %rt46.t1, align 4
  br label %exit_ws_2
}

g successor 1 - $BB_1_0003_entry_ws_2
(0.022173) LLVMUniformVectorization.cpp:1421: adding successor 2 - $BB_1_0004_entry_ws_2
(0.022178) LLVMUniformVectorization.cpp:1424: Created large switch statement in scheduler
(0.022182) LLVMUniformVectorization.cpp:261:  Finalizing subkernel
(0.022187) LLVMUniformVectorization.cpp:265:  end vectorization _Z_ocelotTranslated_sequence_opt3_ws2

(0.025743) LLVMDynamicTranslationCache.cpp:1215: performed transformations
(0.030998) LLVMDynamicTranslationCache.cpp:126:  inserting translation 262144 with 96 bytes of local memory
(0.031008) LLVMDynamicExecutionManager.cpp:103:  Unlocking dynamic execution manager
(0.031015) LLVMDynamicExecutive.cpp:242:   obtained translation. Executing warp on subkernel 262144
(0.031021) LLVMDynamicExecutive.cpp:269:   thread(0, 0, 0) [cta 0] exited with code exit - resume point: 262144
(0.031027) LLVMDynamicExecutive.cpp:269:   thread(1, 0, 0) [cta 0] exited with code exit - resume point: 262144
(0.031033) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 262144
(0.031038) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.031042) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 262144
(0.031046) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 262144, ws: 2)
(0.031051) LLVMDynamicExecutive.cpp:389:  hit local translation cache
(0.031055) LLVMDynamicExecutive.cpp:242:   obtained translation. Executing warp on subkernel 262144
(0.031060) LLVMDynamicExecutive.cpp:269:   thread(2, 0, 0) [cta 0] exited with code exit - resume point: 262144
(0.031064) LLVMDynamicExecutive.cpp:269:   thread(3, 0, 0) [cta 0] exited with code exit - resume point: 262144
cudaMemcpy(0x3230120, 0x322f200) - APP
(0.031089) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel 'testShr'.
(0.031095) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 1, 1
(0.031100) LLVMDynamicExecutionManager.cpp:61:     block dim: 4, 1, 1
(0.031104) LLVMDynamicExecutionManager.cpp:62:     entry id: 131072
(0.031108) LLVMDynamicExecutionManager.cpp:63:     local memory size: 184 bytes
(0.031112) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 1024 bytes 
(0.031116) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.031120) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.031126) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 184, total threads: 4, shared memory size: 1024
(0.031131) LLVMDynamicExecutive.cpp:207:  execute()
(0.031136) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 131072
(0.031140) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.031144) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 131072
(0.031148) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 131072, ws: 2)
(0.031153) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.031157) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 131072, warpsize: 2)
(0.031161) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager
(0.033209) LLVMDynamicTranslationCache.cpp:1037: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_testShr( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$OcelotRegisterInitializerBlock:
	%ri60 = bitcast i32 0 to i32;
	%ri59 = bitcast i32 0 to i32;
	%ri48 = bitcast i32 0 to i32;
	%ri47 = bitcast i32 0 to i32;
	%ri46 = bitcast i64 0 to i64;
	br label %$BB_5_0002;
$BB_5_0002:
	%r0 = bitcast i64 0 to i64;
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0;
	%rt1 = load i32* %rt0;
	%r1 = bitcast i32 %rt1 to i32;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0;
	%rt3 = load i32* %rt2;
	%r2 = bitcast i32 %rt3 to i32;
	%r3 = mul i32 %r1, %r2;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt5 = load i32* %rt4;
	%r4 = bitcast i32 %rt5 to i32;
	%r5 = add i32 %r3, %r4;
	%r6 = mul i32 %r5, 2;
	%r7 = zext i32 %r4 to i64;
	%rt6 = zext i32 %r4 to i64;
	%r8 = mul i64 %rt6, 4;
	%r9 = add i64 %r0, %r8;
	%rt7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 5;
	%rt8 = load i8** %rt7;
	%rt9 = ptrtoint i8* %rt8 to i64;
	%rt10 = add i64 %r9, %rt9;
	%rt11 = inttoptr i64 %rt10 to i32*;
	store i32 %r6, i32* %rt11, align 4;
	br label %$BB_5_0002_bar;
	br label %$BB_5_0002_bar;
$BB_5_0002_bar:
	%r11 = phi i32 [ %r4, %$BB_5_0002 ], [ %r35, %$BB_5_0002_bar_entry ];
	%r12 = phi i32 [ %r5, %$BB_5_0002 ], [ %r34, %$BB_5_0002_bar_entry ];
	%r10 = phi i64 [ %r0, %$BB_5_0002 ], [ %r36, %$BB_5_0002_bar_entry ];
	%r13 = xor i32 %r11, 1;
	%r14 = zext i32 %r13 to i64;
	%rt12 = zext i32 %r13 to i64;
	%r15 = mul i64 %rt12, 4;
	%r16 = add i64 %r10, %r15;
	%rt13 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 5;
	%rt14 = load i8** %rt13;
	%rt15 = ptrtoint i8* %rt14 to i64;
	%rt16 = add i64 %r16, %rt15;
	%rt17 = inttoptr i64 %rt16 to i32*;
	%r17 = load i32* %rt17, align 4;
	%r18 = and i32 %r12, 1;
	%r19 = bitcast i32 0 to i32;
	%r20 = icmp eq i32 %r18, %r19;
	br i1 %r20, label %$BB_5_0004, label %$BB_5_0003;
$BB_5_0003:
	%r22 = phi i32 [ %r12, %$BB_5_0002_bar ], [ %r38, %$BB_5_0003_entry ];
	%r21 = phi i32 [ %r17, %$BB_5_0002_bar ], [ %r39, %$BB_5_0003_entry ];
	%r23 = mul i32 %r21, 19;
	br label %$BB_5_0005;
$BB_5_0004:
	%r24 = phi i32 [ %r42, %$BB_5_0004_entry ], [ %r17, %$BB_5_0002_bar ];
	%r25 = phi i32 [ %r41, %$BB_5_0004_entry ], [ %r12, %$BB_5_0002_bar ];
	%r26 = mul i32 %r24, 13;
	br label %$BB_5_0005;
$BB_5_0005:
	%r27 = phi i32 [ %r45, %$BB_5_0005_entry ], [ %r22, %$BB_5_0003 ], [ %r25, %$BB_5_0004 ];
	%r28 = phi i32 [ %r44, %$BB_5_0005_entry ], [ %r23, %$BB_5_0003 ], [ %r26, %$BB_5_0004 ];
	%rt18 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt19 = load i8** %rt18;
	%rt20 = bitcast i8* %rt19 to i64*;
	%r29 = load i64* %rt20, align 8;
	%r30 = sext i32 %r27 to i64;
	%rt21 = sext i32 %r27 to i64;
	%r31 = mul i64 %rt21, 4;
	%r32 = add i64 %r29, %r31;
	%rt22 = inttoptr i64 %r32 to i32*;
	store i32 %r28, i32* %rt22, align 4;
	br i1 1, label %$BB_5_0005_exit, label %exit;
$BB_5_0002_entry:
	br label %$BB_5_0002;
$BB_5_0002_bar_entry:
	%r33 = bitcast i32 8 to i32;
	%rt23 = zext i32 %r33 to i64;
	%rt24 = add i64 %rt23, 40;
	%rt25 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt26 = load i8** %rt25;
	%rt27 = ptrtoint i8* %rt26 to i64;
	%rt28 = add i64 %rt24, %rt27;
	%rt29 = inttoptr i64 %rt28 to i32*;
	%r34 = load i32* %rt29, align 4;
	%rt30 = zext i32 %r33 to i64;
	%rt31 = add i64 %rt30, 32;
	%rt32 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt33 = load i8** %rt32;
	%rt34 = ptrtoint i8* %rt33 to i64;
	%rt35 = add i64 %rt31, %rt34;
	%rt36 = inttoptr i64 %rt35 to i32*;
	%r35 = load i32* %rt36, align 4;
	%rt37 = zext i32 %r33 to i64;
	%rt38 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt39 = load i8** %rt38;
	%rt40 = ptrtoint i8* %rt39 to i64;
	%rt41 = add i64 %rt37, %rt40;
	%rt42 = inttoptr i64 %rt41 to i64*;
	%r36 = load i64* %rt42, align 8;
	br label %$BB_5_0002_bar;
$BB_5_0003_entry:
	%r37 = bitcast i32 8 to i32;
	%rt43 = zext i32 %r37 to i64;
	%rt44 = add i64 %rt43, 40;
	%rt45 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt46 = load i8** %rt45;
	%rt47 = ptrtoint i8* %rt46 to i64;
	%rt48 = add i64 %rt44, %rt47;
	%rt49 = inttoptr i64 %rt48 to i32*;
	%r38 = load i32* %rt49, align 4;
	%rt50 = zext i32 %r37 to i64;
	%rt51 = add i64 %rt50, 112;
	%rt52 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt53 = load i8** %rt52;
	%rt54 = ptrtoint i8* %rt53 to i64;
	%rt55 = add i64 %rt51, %rt54;
	%rt56 = inttoptr i64 %rt55 to i32*;
	%r39 = load i32* %rt56, align 4;
	br label %$BB_5_0003;
$BB_5_0004_entry:
	%r40 = bitcast i32 8 to i32;
	%rt57 = zext i32 %r40 to i64;
	%rt58 = add i64 %rt57, 40;
	%rt59 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt60 = load i8** %rt59;
	%rt61 = ptrtoint i8* %rt60 to i64;
	%rt62 = add i64 %rt58, %rt61;
	%rt63 = inttoptr i64 %rt62 to i32*;
	%r41 = load i32* %rt63, align 4;
	%rt64 = zext i32 %r40 to i64;
	%rt65 = add i64 %rt64, 112;
	%rt66 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt67 = load i8** %rt66;
	%rt68 = ptrtoint i8* %rt67 to i64;
	%rt69 = add i64 %rt65, %rt68;
	%rt70 = inttoptr i64 %rt69 to i32*;
	%r42 = load i32* %rt70, align 4;
	br label %$BB_5_0004;
$BB_5_0005_entry:
	%r43 = bitcast i32 8 to i32;
	%rt71 = zext i32 %r43 to i64;
	%rt72 = add i64 %rt71, 144;
	%rt73 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt74 = load i8** %rt73;
	%rt75 = ptrtoint i8* %rt74 to i64;
	%rt76 = add i64 %rt72, %rt75;
	%rt77 = inttoptr i64 %rt76 to i32*;
	%r44 = load i32* %rt77, align 4;
	%rt78 = zext i32 %r43 to i64;
	%rt79 = add i64 %rt78, 40;
	%rt80 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt81 = load i8** %rt80;
	%rt82 = ptrtoint i8* %rt81 to i64;
	%rt83 = add i64 %rt79, %rt82;
	%rt84 = inttoptr i64 %rt83 to i32*;
	%r45 = load i32* %rt84, align 4;
	br label %$BB_5_0005;
$BB_5_0002_exit:
	%r46 = phi i64 [ %ri46, %$OcelotRegisterInitializerBlock ];
	%r47 = phi i32 [ %ri47, %$OcelotRegisterInitializerBlock ];
	%r48 = phi i32 [ %ri48, %$OcelotRegisterInitializerBlock ];
	%r49 = bitcast i32 8 to i32;
	%rt85 = zext i32 %r49 to i64;
	%rt86 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt87 = load i8** %rt86;
	%rt88 = ptrtoint i8* %rt87 to i64;
	%rt89 = add i64 %rt85, %rt88;
	%rt90 = inttoptr i64 %rt89 to i64*;
	store i64 %r46, i64* %rt90, align 8;
	%rt91 = zext i32 %r49 to i64;
	%rt92 = add i64 %rt91, 32;
	%rt93 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt94 = load i8** %rt93;
	%rt95 = ptrtoint i8* %rt94 to i64;
	%rt96 = add i64 %rt92, %rt95;
	%rt97 = inttoptr i64 %rt96 to i32*;
	store i32 %r47, i32* %rt97, align 4;
	%rt98 = zext i32 %r49 to i64;
	%rt99 = add i64 %rt98, 40;
	%rt100 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt101 = load i8** %rt100;
	%rt102 = ptrtoint i8* %rt101 to i64;
	%rt103 = add i64 %rt99, %rt102;
	%rt104 = inttoptr i64 %rt103 to i32*;
	store i32 %r48, i32* %rt104, align 4;
	%r50 = bitcast i32 4 to i32;
	%rt105 = zext i32 %r50 to i64;
	%rt106 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt107 = load i8** %rt106;
	%rt108 = ptrtoint i8* %rt107 to i64;
	%rt109 = add i64 %rt105, %rt108;
	%rt110 = inttoptr i64 %rt109 to i32*;
	store i32 1, i32* %rt110, align 4;
	%r51 = bitcast i32 0 to i32;
	%rt111 = zext i32 %r51 to i64;
	%rt112 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt113 = load i8** %rt112;
	%rt114 = ptrtoint i8* %rt113 to i64;
	%rt115 = add i64 %rt111, %rt114;
	%rt116 = inttoptr i64 %rt115 to i32*;
	store i32 5, i32* %rt116, align 4;
	br label %exit;
$BB_5_0002_bar_exit:
	%r52 = phi i32 [ %r17, %$BB_5_0002_bar ];
	%r53 = phi i32 [ %r12, %$BB_5_0002_bar ];
	%r54 = phi i1 [ %r20, %$BB_5_0002_bar ];
	%r55 = bitcast i32 8 to i32;
	%rt117 = zext i32 %r55 to i64;
	%rt118 = add i64 %rt117, 112;
	%rt119 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt120 = load i8** %rt119;
	%rt121 = ptrtoint i8* %rt120 to i64;
	%rt122 = add i64 %rt118, %rt121;
	%rt123 = inttoptr i64 %rt122 to i32*;
	store i32 %r52, i32* %rt123, align 4;
	%rt124 = zext i32 %r55 to i64;
	%rt125 = add i64 %rt124, 40;
	%rt126 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt127 = load i8** %rt126;
	%rt128 = ptrtoint i8* %rt127 to i64;
	%rt129 = add i64 %rt125, %rt128;
	%rt130 = inttoptr i64 %rt129 to i32*;
	store i32 %r53, i32* %rt130, align 4;
	%r56 = select i1 %r54, i32 3, i32 2;
	%r57 = bitcast i32 4 to i32;
	%rt131 = zext i32 %r57 to i64;
	%rt132 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt133 = load i8** %rt132;
	%rt134 = ptrtoint i8* %rt133 to i64;
	%rt135 = add i64 %rt131, %rt134;
	%rt136 = inttoptr i64 %rt135 to i32*;
	store i32 %r56, i32* %rt136, align 4;
	%r58 = bitcast i32 0 to i32;
	%rt137 = zext i32 %r58 to i64;
	%rt138 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt139 = load i8** %rt138;
	%rt140 = ptrtoint i8* %rt139 to i64;
	%rt141 = add i64 %rt137, %rt140;
	%rt142 = inttoptr i64 %rt141 to i32*;
	store i32 2, i32* %rt142, align 4;
	br label %exit;
$BB_5_0004_exit:
	%r59 = phi i32 [ %ri59, %$OcelotRegisterInitializerBlock ];
	%r60 = phi i32 [ %ri60, %$OcelotRegisterInitializerBlock ];
	%r61 = bitcast i32 8 to i32;
	%rt143 = zext i32 %r61 to i64;
	%rt144 = add i64 %rt143, 40;
	%rt145 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt146 = load i8** %rt145;
	%rt147 = ptrtoint i8* %rt146 to i64;
	%rt148 = add i64 %rt144, %rt147;
	%rt149 = inttoptr i64 %rt148 to i32*;
	store i32 %r59, i32* %rt149, align 4;
	%rt150 = zext i32 %r61 to i64;
	%rt151 = add i64 %rt150, 144;
	%rt152 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt153 = load i8** %rt152;
	%rt154 = ptrtoint i8* %rt153 to i64;
	%rt155 = add i64 %rt151, %rt154;
	%rt156 = inttoptr i64 %rt155 to i32*;
	store i32 %r60, i32* %rt156, align 4;
	ret void;
$BB_5_0005_exit:
	%r62 = bitcast i32 0 to i32;
	%rt157 = zext i32 %r62 to i64;
	%rt158 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt159 = load i8** %rt158;
	%rt160 = ptrtoint i8* %rt159 to i64;
	%rt161 = add i64 %rt157, %rt160;
	%rt162 = inttoptr i64 %rt161 to i32*;
	store i32 6, i32* %rt162, align 4;
	br label %exit;
exit:
	ret void;

}

(0.035071) LLVMUniformVectorization.cpp:222:  Vectorization: _Z_ocelotTranslated_testShr_opt3_ws2
(0.035079) LLVMUniformVectorization.cpp:226:  Breadth first traversal:
(0.035095) LLVMUniformVectorization.cpp:229:  Creating prolog block to replace scheduler
(0.035100) LLVMUniformVectorization.cpp:232:  Loading thread-local values
(0.035105) LLVMUniformVectorization.cpp:383:  loadThreadLocalArguments
(0.035134) LLVMUniformVectorization.cpp:239:  Adding interleaved and replicated instructions:
(0.035149) LLVMUniformVectorization.cpp:449:  AddInterleavedInstructions()
(0.035154) LLVMUniformVectorization.cpp:454:    traversal contains:
(0.035158) LLVMUniformVectorization.cpp:459:    - $OcelotRegisterInitializerBlock
(0.035166) LLVMUniformVectorization.cpp:472:      [ constructed as $OcelotRegisterInitializerBlock_ws_2]
(0.035172) LLVMUniformVectorization.cpp:459:    - $BB_5_0002
(0.035178) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0002_ws_2]
(0.035183) LLVMUniformVectorization.cpp:459:    - $BB_5_0002_bar
(0.035189) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0002_bar_ws_2]
(0.035194) LLVMUniformVectorization.cpp:459:    - $BB_5_0004
(0.035199) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0004_ws_2]
(0.035205) LLVMUniformVectorization.cpp:459:    - $BB_5_0003
(0.035210) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0003_ws_2]
(0.035215) LLVMUniformVectorization.cpp:459:    - $BB_5_0005
(0.035221) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0005_ws_2]
(0.035226) LLVMUniformVectorization.cpp:459:    - $BB_5_0005_exit
(0.035232) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0005_exit_ws_2]
(0.035237) LLVMUniformVectorization.cpp:459:    - exit
(0.035243) LLVMUniformVectorization.cpp:472:      [ constructed as exit_ws_2]
(0.035248) LLVMUniformVectorization.cpp:459:    - 
(0.035252) LLVMUniformVectorization.cpp:459:    - $BB_5_0002_entry
(0.035257) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0002_entry_ws_2]
(0.035271) LLVMUniformVectorization.cpp:459:    - $BB_5_0002_bar_entry
(0.035277) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0002_bar_entry_ws_2]
(0.035282) LLVMUniformVectorization.cpp:459:    - $BB_5_0003_entry
(0.035288) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0003_entry_ws_2]
(0.035293) LLVMUniformVectorization.cpp:459:    - $BB_5_0004_entry
(0.035299) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0004_entry_ws_2]
(0.035305) LLVMUniformVectorization.cpp:459:    - $BB_5_0005_entry
(0.035319) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0005_entry_ws_2]
(0.035324) LLVMUniformVectorization.cpp:459:    - $BB_5_0002_exit
(0.035330) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0002_exit_ws_2]
(0.035335) LLVMUniformVectorization.cpp:459:    - $BB_5_0002_bar_exit
(0.035340) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0002_bar_exit_ws_2]
(0.035345) LLVMUniformVectorization.cpp:459:    - $BB_5_0004_exit
(0.035351) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_5_0004_exit_ws_2]
(0.036180) LLVMUniformVectorization.cpp:242:  Updating data dependencies among replicated instructions
(0.036271) LLVMUniformVectorization.cpp:245:  Updating control flow among warp-synchronous replicated blocks
(0.036293) LLVMUniformVectorization.cpp:248:  Vectorizing replicated instruction bundles
(0.036417) LLVMUniformVectorization.cpp:255:  Removing superfluous scalar blocks
(0.036513) LLVMUniformVectorization.cpp:258:  Creating scheduler block
(0.036521) LLVMUniformVectorization.cpp:1373: Updating subkernel entry points
(0.036535) LLVMUniformVectorization.cpp:1399: There are 5 entry points
(0.036545) LLVMUniformVectorization.cpp:1344: seeking label BB_5_0002_entry_ws
(0.036552) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.036560) LLVMUniformVectorization.cpp:1356: possible entry block: 
(0.036568) LLVMUniformVectorization.cpp:1356: possible entry block: $OcelotRegisterInitializerBlock_ws_2
(0.036576) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_ws_2
(0.036583) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_bar_ws_2
(0.036591) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0004_ws_2
(0.036598) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0003_ws_2
(0.036606) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_ws_2
(0.036614) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_exit_ws_2
(0.036638) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.036649) LLVMUniformVectorization.cpp:1344: seeking label BB_5_0002_bar_entry_ws
(0.036657) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.036665) LLVMUniformVectorization.cpp:1356: possible entry block: 
(0.036673) LLVMUniformVectorization.cpp:1356: possible entry block: $OcelotRegisterInitializerBlock_ws_2
(0.036681) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_ws_2
(0.036689) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_bar_ws_2
(0.036697) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0004_ws_2
(0.036705) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0003_ws_2
(0.036713) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_ws_2
(0.036722) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_exit_ws_2
(0.036731) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.036740) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_entry_ws_2
(0.036751) LLVMUniformVectorization.cpp:1344: seeking label BB_5_0003_entry_ws
(0.036760) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.036768) LLVMUniformVectorization.cpp:1356: possible entry block: 
(0.036777) LLVMUniformVectorization.cpp:1356: possible entry block: $OcelotRegisterInitializerBlock_ws_2
(0.036784) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_ws_2
(0.036792) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_bar_ws_2
(0.036800) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0004_ws_2
(0.036809) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0003_ws_2
(0.036817) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_ws_2
(0.036824) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_exit_ws_2
(0.036832) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.036839) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_entry_ws_2
(0.036847) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_bar_entry_ws_2
(0.036856) LLVMUniformVectorization.cpp:1344: seeking label BB_5_0004_entry_ws
(0.036864) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.036870) LLVMUniformVectorization.cpp:1356: possible entry block: 
(0.036877) LLVMUniformVectorization.cpp:1356: possible entry block: $OcelotRegisterInitializerBlock_ws_2
(0.036885) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_ws_2
(0.036895) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_bar_ws_2
(0.036904) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0004_ws_2
(0.036912) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0003_ws_2
(0.036922) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_ws_2
(0.036930) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_exit_ws_2
(0.036940) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.036948) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_entry_ws_2
(0.036957) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_bar_entry_ws_2
(0.036966) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0003_entry_ws_2
(0.036976) LLVMUniformVectorization.cpp:1344: seeking label BB_5_0005_entry_ws
(0.036984) LLVMUniformVectorization.cpp:1356: possible entry block: WarpSynchronousEntry
(0.036991) LLVMUniformVectorization.cpp:1356: possible entry block: 
(0.036999) LLVMUniformVectorization.cpp:1356: possible entry block: $OcelotRegisterInitializerBlock_ws_2
(0.037006) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_ws_2
(0.037014) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_bar_ws_2
(0.037021) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0004_ws_2
(0.03TestCudaSequence: /home/akerr/repositories/llvm/include/llvm/Analysis/Dominators.h:499: void llvm::DominatorTreeBase<NodeT>::changeImmediateDominator(llvm::DomTreeNodeBase<NodeT>*, llvm::DomTreeNodeBase<NodeT>*) [with NodeT = llvm::BasicBlock]: Assertion `N && NewIDom && "Cannot change null node pointers!"' failed.
7028) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0003_ws_2
(0.037046) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_ws_2
(0.037062) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0005_exit_ws_2
(0.037071) LLVMUniformVectorization.cpp:1356: possible entry block: exit_ws_2
(0.037081) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_entry_ws_2
(0.037090) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0002_bar_entry_ws_2
(0.037100) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0003_entry_ws_2
(0.037110) LLVMUniformVectorization.cpp:1356: possible entry block: $BB_5_0004_entry_ws_2
(0.037121) LLVMUniformVectorization.cpp:1414: Created switch with 5 cases
(0.037132) LLVMUniformVectorization.cpp:1421: adding successor 0 - $BB_5_0002_entry_ws_2
(0.037143) LLVMUniformVectorization.cpp:1421: adding successor 1 - $BB_5_0002_bar_entry_ws_2
(0.037153) LLVMUniformVectorization.cpp:1421: adding successor 2 - $BB_5_0003_entry_ws_2
(0.037163) LLVMUniformVectorization.cpp:1421: adding successor 3 - $BB_5_0004_entry_ws_2
(0.037174) LLVMUniformVectorization.cpp:1421: adding successor 4 - $BB_5_0005_entry_ws_2
(0.037184) LLVMUniformVectorization.cpp:1424: Created large switch statement in scheduler
(0.037194) LLVMUniformVectorization.cpp:261:  Finalizing subkernel
(0.037204) LLVMUniformVectorization.cpp:265:  end vectorization _Z_ocelotTranslated_testShr_opt3_ws2

Stack dump:
0.	Running pass 'Global Value Numbering' on function '@_Z_ocelotTranslated_testShr_opt3_ws2'

INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLLVMKernels
INFO     Test completed in 0.0562429428101 seconds
INFO      It produced the following output:
(0.018860) LLVMUniformVectorization.cpp:222:  Vectorization: _Z_ocelotTranslated__Z17k_sequenceLoopingPfi
(0.018885) LLVMUniformVectorization.cpp:226:  Breadth first traversal:
(0.018924) LLVMUniformVectorization.cpp:229:  Creating prolog block to replace scheduler
(0.018936) LLVMUniformVectorization.cpp:232:  Loading thread-local values
(0.018945) LLVMUniformVectorization.cpp:383:  loadThreadLocalArguments
(0.019008) LLVMUniformVectorization.cpp:239:  Adding interleaved and replicated instructions:
(0.019020) LLVMUniformVectorization.cpp:449:  AddInterleavedInstructions()
(0.019029) LLVMUniformVectorization.cpp:454:    traversal contains:
(0.019039) LLVMUniformVectorization.cpp:459:    - _Z17k_sequenceLoopingPfi_scheduler
(0.019053) LLVMUniformVectorization.cpp:472:      [ constructed as _Z17k_sequenceLoopingPfi_scheduler_ws_2]
(0.019065) LLVMUniformVectorization.cpp:459:    - $BB_1_0023_restore
(0.019078) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0023_restore_ws_2]
(0.019089) LLVMUniformVectorization.cpp:459:    - _Z17k_sequenceLoopingPfi_scheduler_39
(0.019101) LLVMUniformVectorization.cpp:472:      [ constructed as _Z17k_sequenceLoopingPfi_scheduler_39_ws_2]
(0.019112) LLVMUniformVectorization.cpp:459:    - $BB_1_0023
(0.019124) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0023_ws_2]
(0.019135) LLVMUniformVectorization.cpp:459:    - $BB_1_0024_restore
(0.019147) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0024_restore_ws_2]
(0.019158) LLVMUniformVectorization.cpp:459:    - _Z17k_sequenceLoopingPfi_scheduler_40
(0.019170) LLVMUniformVectorization.cpp:472:      [ constructed as _Z17k_sequenceLoopingPfi_scheduler_40_ws_2]
(0.019181) LLVMUniformVectorization.cpp:459:    - $BB_1_0025
(0.019194) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0025_ws_2]
(0.019204) LLVMUniformVectorization.cpp:459:    - $BB_1_0024
(0.019215) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0024_ws_2]
(0.019226) LLVMUniformVectorization.cpp:459:    - $BB_1_0025_restore
(0.019237) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0025_restore_ws_2]
(0.019248) LLVMUniformVectorization.cpp:459:    - _Z17k_sequenceLoopingPfi_scheduler_41
(0.019261) LLVMUniformVectorization.cpp:472:      [ constructed as _Z17k_sequenceLoopingPfi_scheduler_41_ws_2]
(0.019273) LLVMUniformVectorization.cpp:459:    - $BB_1_0026
(0.019285) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0026_ws_2]
(0.019295) LLVMUniformVectorization.cpp:459:    - $BB_1_0004_restore
(0.019308) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0004_restore_ws_2]
(0.019319) LLVMUniformVectorization.cpp:459:    - _Z17k_sequenceLoopingPfi_scheduler_42
(0.019331) LLVMUniformVectorization.cpp:472:      [ constructed as _Z17k_sequenceLoopingPfi_scheduler_42_ws_2]
(0.019341) LLVMUniformVectorization.cpp:459:    - $BB_1_0027
(0.019354) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0027_ws_2]
(0.019365) LLVMUniformVectorization.cpp:459:    - $BB_1_0004
(0.019377) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0004_ws_2]
(0.019388) LLVMUniformVectorization.cpp:459:    - $BB_1_0027_restore
(0.019400) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0027_restore_ws_2]
(0.019410) LLVMUniformVectorization.cpp:459:    - _Z17k_sequenceLoopingPfi_scheduler_43
(0.019423) LLVMUniformVectorization.cpp:472:      [ constructed as _Z17k_sequenceLoopingPfi_scheduler_43_ws_2]
(0.019434) LLVMUniformVectorization.cpp:459:    - exit
(0.019446) LLVMUniformVectorization.cpp:472:      [ constructed as exit_ws_2]
(0.019456) LLVMUniformVectorization.cpp:459:    - $BB_1_0004_bounce
(0.019468) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0004_bounce_ws_2]
(0.019478) LLVMUniformVectorization.cpp:459:    - $BB_1_0022
(0.019489) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0022_ws_2]
(0.019499) LLVMUniformVectorization.cpp:459:    - $BB_1_0026_restore
(0.019510) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0026_rTestLLVMKernels: ocelot/analysis/implementation/LLVMUniformVectorization.cpp:852: void analysis::LLVMUniformVectorization::Translation::handleDivergentBranch(analysis::LLVMUniformVectorization::DivergentBranch&): Assertion `divergent.handler && "Failed in finding existing divergence handler"' failed.
estore_ws_2]
(0.019533) LLVMUniformVectorization.cpp:459:    - _Z17k_sequenceLoopingPfi_scheduler_44
(0.019545) LLVMUniformVectorization.cpp:472:      [ constructed as _Z17k_sequenceLoopingPfi_scheduler_44_ws_2]
(0.019555) LLVMUniformVectorization.cpp:459:    - $BB_1_0005_save
(0.019566) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0005_save_ws_2]
(0.019575) LLVMUniformVectorization.cpp:459:    - $BB_1_0022_restore
(0.019586) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0022_restore_ws_2]
(0.019596) LLVMUniformVectorization.cpp:459:    - _Z17k_sequenceLoopingPfi_scheduler_trampoline
(0.019607) LLVMUniformVectorization.cpp:472:      [ constructed as _Z17k_sequenceLoopingPfi_scheduler_trampoline_ws_2]
(0.019616) LLVMUniformVectorization.cpp:459:    - $BB_1_0002
(0.019628) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0002_ws_2]
(0.019639) LLVMUniformVectorization.cpp:459:    - $BB_1_0003_save
(0.019651) LLVMUniformVectorization.cpp:472:      [ constructed as $BB_1_0003_save_ws_2]
(0.022402) LLVMUniformVectorization.cpp:242:  Updating data dependencies among replicated instructions
(0.022557) LLVMUniformVectorization.cpp:245:  Updating control flow among warp-synchronous replicated blocks
(0.022607) LLVMUniformVectorization.cpp:850:  Failed in finding existing divergence handler for block $BB_1_0023_exit_ws_2
Stack dump:
0.	Running pass 'Function Pass Manager' on module '_Z17k_sequenceLoopingPfi'.
1.	Running pass 'Ocelot LLVM Uniform Vectorization' on function '@_Z_ocelotTranslated__Z17k_sequenceLoopingPfi'

INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaMalloc
INFO     Test completed in 0.04070520401 seconds
INFO      It produced the following output:
test_malloc(256, 128)
PASSED
test_mallocArray(256, 128)
checking results from last cudaMemcpyFromArray
PASSED
[1] mallocing pitch
[2] memcpying2d
[3] memcpying
[4] checking for errors
[5] mallocing
[6] memcpying
[7] memcpying
[8] final free
Pass/Fail : Pass

INFO     Test /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestIndirectFunctionCall
INFO     Test completed in 0.0334210395813 seconds
INFO      It produced the following output:
(0.002628) LLVMDynamicExecutionManager.cpp:47:   Launching LLVM kernel 'kernelEntry'.
(0.002645) LLVMDynamicTranslationCache.cpp:145:  LLVMDynamicTranslationCache::loadModule() - indirectCall.cu
(0.002653) KernelPartitioningPass.cpp:593:  Run on kernel 'funcQuadruple'
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .s32 __cudaretf_funcQuadruple) funcQuadruple(.param  .s32 __cudaparmf1_funcQuadruple)
{

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	$BB_3_0002:				/* $LDWbegin_funcQuadruple */ 
		ld.param.u32 %r0, [__cudaparmf1_funcQuadruple];
		mov.s32 %r1, %r0;
		mul.lo.s32 %r2, %r1, 4;
		st.param.s32 [__cudaretf_funcQuadruple], %r2;
		ret;
}
(0.002702) KernelPartitioningPass.cpp:596:  


(0.002739) KernelPartitioningPass.cpp:145:    Spill region size is 16
(0.002745) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.002749) KernelPartitioningPass.cpp:159:   block entry
(0.002754) KernelPartitioningPass.cpp:159:   block exit
(0.002758) KernelPartitioningPass.cpp:159:   block $BB_3_0002
(0.002790) KernelPartitioningPass.cpp:185:  identifying transition points
(0.002800) KernelPartitioningPass.cpp:199:   block $BB_3_0002
(0.002808) KernelPartitioningPass.cpp:229:   block $BB_3_0002
(0.002819) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = ret
(0.002824) KernelPartitioningPass.cpp:360:    terminator->toString() = ret
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .s32 __cudaretf_funcQuadruple) funcQuadruple(.param  .s32 __cudaparmf1_funcQuadruple)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[16];

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	$BB_3_0002:				/* $LDWbegin_funcQuadruple */ 
		ld.param.u32 %r0, [__cudaparmf1_funcQuadruple];
		mov.s32 %r1, %r0;
		mul.lo.s32 %r2, %r1, 4;
		st.param.s32 [__cudaretf_funcQuadruple], %r2;
		ret;
	$BB_3_0002_entry:				/* entryId: 0 */ 
		bra $BB_3_0002;
	$BB_3_0002_exit:
}
(0.002943) KernelPartitioningPass.cpp:593:  Run on kernel 'kernelEntry'
/*
* Ocelot Version : 2.0.896
*/
.entry kernelEntry(.param  .u64 __cudaparm_kernelEntry_A,
		.param  .s32 __cudaparm_kernelEntry_b)
{

	.param  .s32 __cudaparma1_fproto_i_i;
	.param  .s32 __cudareta_fproto_i_i;
	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .pred %p9;
	.reg .u64 %r10;
	.reg .u32 %r11;
	.reg .pred %p12;
	.reg .u32 %r13;
	.reg .pred %p14;
	.reg .u64 %r15;
	.reg .u64 %r17;
	.reg .u64 %r16;
	.reg .u32 %r18;
	.reg .pred %p19;
	.reg .u32 %r20;
	.reg .u32 %r21;
	.reg .u32 %r22;
	.reg .u32 %r23;
	.reg .u64 %r24;
	.reg .u64 %r25;
	.reg .u64 %r26;
	
	fproto_i_i: .callprototype (.param .s32 _) _ (.param .s32 _);
	
	$BB_5_0002:				/* $LDWbegin_kernelEntry */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %tid.x;
		add.u32 %r4, %r3, %r2;
		ld.param.s32 %r5, [__cudaparm_kernelEntry_b];
		add.s32 %r6, %r5, %r4;
		and.b32 %r7, %r6, 3;
		mov.u32 %r8, 0;
		setp.ne.s32 %p9, %r7, %r8;
		@%p9 bra $BB_5_0004;
	$BB_5_0003:
		mov.u64 %r10, funcDouble;
		bra.uni $BB_5_0009;
	$BB_5_0008:				/* $Lt_4_4610 */ 
		mov.u64 %r15, funcPentuple;
		mov.s64 %r17, %r16;
		mov.s32 %r18, 3;
		setp.eq.s32 %p19, %r7, %r18;
		selp.u64 %r10, %r15, %r17, %p19;
	$BB_5_0009:				/* $Lt_4_3330 */ 
		mov.s32 %r20, %r4;
		st.param.u32 [__cudaparma1_fproto_i_i], %r20;
		call (__cudareta_fproto_i_i), %r10, (__cudaparma1_fproto_i_i), fproto_i_i;
		ld.param.s32 %r21, [__cudareta_fproto_i_i];
		mov.s32 %r22, %r21;
		mul.lo.u32 %r23, %r4, 4;
		cvt.u64.u32 %r24, %r23;
		ld.param.u64 %r25, [__cudaparm_kernelEntry_A];
		add.u64 %r26, %r24, %r25;
		st.s32 [%r26 + 0], %r22;
		exit;
	$BB_5_0004:				/* $Lt_4_3586 */ 
		mov.u32 %r11, 1;
		setp.ne.s32 %p12, %r7, %r11;
		@%p12 bra $BB_5_0006;
	$BB_5_0005:
		mov.u64 %r10, funcTriple;
		bra.uni $BB_5_0009;
	$BB_5_0006:				/* $Lt_4_4098 */ 
		mov.u32 %r13, 2;
		setp.ne.s32 %p14, %r7, %r13;
		@%p14 bra $BB_5_0008;
	$BB_5_0007:
		mov.u64 %r10, funcQuadruple;
		bra.uni $BB_5_0009;
}
(0.003157) KernelPartitioningPass.cpp:596:  


(0.003401) KernelPartitioningPass.cpp:145:    Spill region size is 208
(0.003411) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.003417) KernelPartitioningPass.cpp:159:   block entry
(0.003424) KernelPartitioningPass.cpp:159:   block exit
(0.003432) KernelPartitioningPass.cpp:159:   block $BB_5_0002
(0.003438) KernelPartitioningPass.cpp:159:   block $BB_5_0003
(0.003444) KernelPartitioningPass.cpp:159:   block $BB_5_0004
(0.003449) KernelPartitioningPass.cpp:159:   block $BB_5_0005
(0.003457) KernelPartitioningPass.cpp:159:   block $BB_5_0006
(0.003465) KernelPartitioningPass.cpp:159:   block $BB_5_0007
(0.003470) KernelPartitioningPass.cpp:159:   block $BB_5_0008
(0.003478) KernelPartitioningPass.cpp:159:   block $BB_5_0009
(0.003769) KernelPartitioningPass.cpp:185:  identifying transition points
(0.003791) KernelPartitioningPass.cpp:199:   block $BB_5_0002
(0.003803) KernelPartitioningPass.cpp:199:   block $BB_5_0003
(0.003815) KernelPartitioningPass.cpp:199:   block $BB_5_0004
(0.003827) KernelPartitioningPass.cpp:199:   block $BB_5_0005
(0.003838) KernelPartitioningPass.cpp:199:   block $BB_5_0006
(0.003850) KernelPartitioningPass.cpp:199:   block $BB_5_0007
(0.003861) KernelPartitioningPass.cpp:199:   block $BB_5_0008
(0.003874) KernelPartitioningPass.cpp:199:   block $BB_5_0009
(0.003886) KernelPartitioningPass.cpp:229:   block $BB_5_0002
(0.003895) KernelPartitioningPass.cpp:229:   block $BB_5_0003
(0.003906) KernelPartitioningPass.cpp:229:   block $BB_5_0004
(0.003916) KernelPartitioningPass.cpp:229:   block $BB_5_0005
(0.003926) KernelPartitioningPass.cpp:229:   block $BB_5_0006
(0.003937) KernelPartitioningPass.cpp:229:   block $BB_5_0007
(0.003947) KernelPartitioningPass.cpp:229:   block $BB_5_0008
(0.003959) KernelPartitioningPass.cpp:229:   block $BB_5_0009
(0.003996) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bra
(0.004008) KernelPartitioningPass.cpp:360:    terminator->toString() = @%p9 bra $BB_5_0004
(0.004025) KernelPartitioningPass.cpp:549:  created exit in block '$BB_5_0002_exit' with code 2
(0.004037) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bra
(0.004046) KernelPartitioningPass.cpp:360:    terminator->toString() = bra.uni $BB_5_0009
(0.004059) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bra
(0.004069) KernelPartitioningPass.cpp:360:    terminator->toString() = @%p12 bra $BB_5_0006
(0.004082) KernelPartitioningPass.cpp:549:  created exit in block '$BB_5_0004_exit' with code 2
(0.004093) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bra
(0.004102) KernelPartitioningPass.cpp:360:    terminator->toString() = bra.uni $BB_5_0009
(0.004113) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bra
(0.004124) KernelPartitioningPass.cpp:360:    terminator->toString() = @%p14 bra $BB_5_0008
(0.004137) KernelPartitioningPass.cpp:549:  created exit in block '$BB_5_0006_exit' with code 2
(0.004148) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = bra
(0.004157) KernelPartitioningPass.cpp:360:    terminator->toString() = bra.uni $BB_5_0009
(0.004167) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = selp
(0.004182) KernelPartitioningPass.cpp:360:    terminator->toString() = selp.u64 %r10, %r15, %r17, %p19
(0.004189) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = exit
(0.004195) KernelPartitioningPass.cpp:360:    terminator->toString() = exit
(0.004206) KernelPartitioningPass.cpp:549:  created exit in block '$BB_5_0009_exit' with code 6
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.entry kernelEntry(.param  .u64 __cudaparm_kernelEntry_A,
		.param  .s32 __cudaparm_kernelEntry_b)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[208];

	.param  .s32 __cudaparma1_fproto_i_i;
	.param  .s32 __cudareta_fproto_i_i;
	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	.reg .u32 %r3;
	.reg .u32 %r4;
	.reg .u32 %r5;
	.reg .u32 %r6;
	.reg .u32 %r7;
	.reg .u32 %r8;
	.reg .pred %p9;
	.reg .u64 %r10;
	.reg .u32 %r11;
	.reg .pred %p12;
	.reg .u32 %r13;
	.reg .pred %p14;
	.reg .u64 %r15;
	.reg .u64 %r17;
	.reg .u64 %r16;
	.reg .u32 %r18;
	.reg .pred %p19;
	.reg .u32 %r20;
	.reg .u32 %r21;
	.reg .u32 %r22;
	.reg .u32 %r23;
	.reg .u64 %r24;
	.reg .u64 %r25;
	.reg .u64 %r26;
	.reg .u32 %r27;
	.reg .u32 %r28;
	.reg .u32 %r29;
	.reg .u32 %r30;
	.reg .u32 %r31;
	.reg .u32 %r32;
	.reg .u32 %r33;
	.reg .u32 %r34;
	.reg .u32 %r35;
	.reg .u32 %r36;
	.reg .u32 %r37;
	.reg .u32 %r39;
	.reg .u32 %r40;
	.reg .u32 %r41;
	.reg .u32 %r43;
	.reg .u32 %r44;
	.reg .u32 %r45;
	.reg .u32 %r47;
	.reg .u32 %r48;
	
	fproto_i_i: .callprototype (.param .s32 _) _ (.param .s32 _);
	
	$BB_5_0002:				/* $LDWbegin_kernelEntry */ 
		mov.u32 %r0, %ctaid.x;
		mov.u32 %r1, %ntid.x;
		mul.lo.u32 %r2, %r0, %r1;
		mov.u32 %r3, %tid.x;
		add.u32 %r4, %r3, %r2;
		ld.param.s32 %r5, [__cudaparm_kernelEntry_b];
		add.s32 %r6, %r5, %r4;
		and.b32 %r7, %r6, 3;
		mov.u32 %r8, 0;
		setp.ne.s32 %p9, %r7, %r8;
		@%p9 bra $BB_5_0004;
	$BB_5_0003:
		mov.u64 %r10, funcDouble;
		bra.uni $BB_5_0009;
	$BB_5_0008:				/* $Lt_4_4610 */ 
		mov.u64 %r15, funcPentuple;
		mov.s64 %r17, %r16;
		mov.s32 %r18, 3;
		setp.eq.s32 %p19, %r7, %r18;
		selp.u64 %r10, %r15, %r17, %p19;
	$BB_5_0009:				/* $Lt_4_3330 */ 
		mov.s32 %r20, %r4;
		st.param.u32 [__cudaparma1_fproto_i_i], %r20;
		call (__cudareta_fproto_i_i), %r10, (__cudaparma1_fproto_i_i), fproto_i_i;
		ld.param.s32 %r21, [__cudareta_fproto_i_i];
		mov.s32 %r22, %r21;
		mul.lo.u32 %r23, %r4, 4;
		cvt.u64.u32 %r24, %r23;
		ld.param.u64 %r25, [__cudaparm_kernelEntry_A];
		add.u64 %r26, %r24, %r25;
		st.s32 [%r26 + 0], %r22;
		bra $BB_5_0009_exit;
	$BB_5_0006_exit:				/* divergent branch */ 
		mov.s32 %r43, _Zocelot_spill_area;
		st.local.s32 [%r43 + 0], %r0;
		st.local.u32 [%r43 + 32], %r4;
		st.local.u64 [%r43 + 128], %r16;
		st.local.u32 [%r43 + 56], %r7;
		selp.s32 %r44, 6, 5, %p14;
		mov.u32 %r45, _Zocelot_resume_point;
		st.local.u32 [%r45 + 0], %r44;
		mov.u32 %r45, _Zocelot_resume_status;
		st.local.u32 [%r45 + 0], 2;
		yield;
	$BB_5_0008_exit:
		mov.s32 %r47, _Zocelot_spill_area;
		st.local.s32 [%r47 + 0], %r0;
		st.local.u32 [%r47 + 32], %r4;
		st.local.u64 [%r47 + 80], %r10;
	$BB_5_0009_exit:				/* exit */ 
		mov.u32 %r48, _Zocelot_resume_status;
		st.local.u32 [%r48 + 0], 6;
		yield;
	$BB_5_0004:				/* $Lt_4_3586 */ 
		mov.u32 %r11, 1;
		setp.ne.s32 %p12, %r7, %r11;
		@%p12 bra $BB_5_0006;
	$BB_5_0005:
		mov.u64 %r10, funcTriple;
		bra.uni $BB_5_0009;
	$BB_5_0006:				/* $Lt_4_4098 */ 
		mov.u32 %r13, 2;
		setp.ne.s32 %p14, %r7, %r13;
		@%p14 bra $BB_5_0008;
	$BB_5_0007:
		mov.u64 %r10, funcQuadruple;
		bra.uni $BB_5_0009;
	$BB_5_0002_entry:				/* entryId: 0 */ 
		mov.s32 %r27, _Zocelot_spill_area;
		ld.local.u64 %r16, [%r27 + 128];
		bra $BB_5_0002;
	$BB_5_0003_entry:				/* entryId: 1 */ 
		mov.s32 %r28, _Zocelot_spill_area;
		ld.local.u32 %r4, [%r28 + 32];
		ld.local.s32 %r0, [%r28 + 0];
		bra $BB_5_0003;
	$BB_5_0004_entry:				/* entryId: 2 */ 
		mov.s32 %r29, _Zocelot_spill_area;
		ld.local.u32 %r7, [%r29 + 56];
		ld.local.u64 %r16, [%r29 + 128];
		ld.local.u32 %r4, [%r29 + 32];
		ld.local.s32 %r0, [%r29 + 0];
		bra $BB_5_0004;
	$BB_5_0005_entry:				/* entryId: 3 */ 
		mov.s32 %r30, _Zocelot_spill_area;
		ld.local.u32 %r4, [%r30 + 32];
		ld.local.s32 %r0, [%r30 + 0];
		bra $BB_5_0005;
	$BB_5_0006_entry:				/* entryId: 4 */ 
		mov.s32 %r31, _Zocelot_spill_area;
		ld.local.u32 %r7, [%r31 + 56];
		ld.local.u64 %r16, [%r31 + 128];
		ld.local.u32 %r4, [%r31 + 32];
		ld.local.s32 %r0, [%r31 + 0];
		bra $BB_5_0006;
	$BB_5_0007_entry:				/* entryId: 5 */ 
		mov.s32 %r32, _Zocelot_spill_area;
		ld.local.u32 %r4, [%r32 + 32];
		ld.local.s32 %r0, [%r32 + 0];
		bra $BB_5_0007;
	$BB_5_0008_entry:				/* entryId: 6 */ 
		mov.s32 %r33, _Zocelot_spill_area;
		ld.local.u32 %r7, [%r33 + 56];
		ld.local.u64 %r16, [%r33 + 128];
		ld.local.u32 %r4, [%r33 + 32];
		ld.local.s32 %r0, [%r33 + 0];
		bra $BB_5_0008;
	$BB_5_0009_entry:				/* entryId: 7 */ 
		mov.s32 %r34, _Zocelot_spill_area;
		ld.local.u64 %r10, [%r34 + 80];
		ld.local.u32 %r4, [%r34 + 32];
		ld.local.s32 %r0, [%r34 + 0];
		bra $BB_5_0009;
	$BB_5_0002_exit:				/* divergent branch */ 
		mov.s32 %r35, _Zocelot_spill_area;
		st.local.s32 [%r35 + 0], %r0;
		st.local.u32 [%r35 + 32], %r4;
		st.local.u64 [%r35 + 128], %r16;
		st.local.u32 [%r35 + 56], %r7;
		selp.s32 %r36, 2, 1, %p9;
		mov.u32 %r37, _Zocelot_resume_point;
		st.local.u32 [%r37 + 0], %r36;
		mov.u32 %r37, _Zocelot_resume_status;
		st.local.u32 [%r37 + 0], 2;
		yield;
	$BB_5_0004_exit:				/* divergent branch */ 
		mov.s32 %r39, _Zocelot_spill_area;
		st.local.s32 [%r39 + 0], %r0;
		st.local.u32 [%r39 + 32], %r4;
		st.local.u64 [%r39 + 128], %r16;
		st.local.u32 [%r39 + 56], %r7;
		selp.s32 %r40, 4, 3, %p12;
		mov.u32 %r41, _Zocelot_resume_point;
		st.local.u32 [%r41 + 0], %r40;
		mov.u32 %r41, _Zocelot_resume_status;
		st.local.u32 [%r41 + 0], 2;
		yield;
}
(0.005625) KernelPartitioningPass.cpp:593:  Run on kernel 'funcPentuple'
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .s32 __cudaretf_funcPentuple) funcPentuple(.param  .s32 __cudaparmf1_funcPentuple)
{

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	$BB_4_0002:				/* $LDWbegin_funcPentuple */ 
		ld.param.u32 %r0, [__cudaparmf1_funcPentuple];
		mov.s32 %r1, %r0;
		mul.lo.s32 %r2, %r1, 5;
		st.param.s32 [__cudaretf_funcPentuple], %r2;
		ret;
}
(0.005677) KernelPartitioningPass.cpp:596:  


(0.005722) KernelPartitioningPass.cpp:145:    Spill region size is 16
(0.005729) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.005736) KernelPartitioningPass.cpp:159:   block entry
(0.005742) KernelPartitioningPass.cpp:159:   block exit
(0.005750) KernelPartitioningPass.cpp:159:   block $BB_4_0002
(0.005791) KernelPartitioningPass.cpp:185:  identifying transition points
(0.005803) KernelPartitioningPass.cpp:199:   block $BB_4_0002
(0.005815) KernelPartitioningPass.cpp:229:   block $BB_4_0002
(0.005829) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = ret
(0.005836) KernelPartitioningPass.cpp:360:    terminator->toString() = ret
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .s32 __cudaretf_funcPentuple) funcPentuple(.param  .s32 __cudaparmf1_funcPentuple)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[16];

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	$BB_4_0002:				/* $LDWbegin_funcPentuple */ 
		ld.param.u32 %r0, [__cudaparmf1_funcPentuple];
		mov.s32 %r1, %r0;
		mul.lo.s32 %r2, %r1, 5;
		st.param.s32 [__cudaretf_funcPentuple], %r2;
		ret;
	$BB_4_0002_entry:				/* entryId: 0 */ 
		bra $BB_4_0002;
	$BB_4_0002_exit:
}
(0.005951) KernelPartitioningPass.cpp:593:  Run on kernel 'funcTriple'
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .s32 __cudaretf_funcTriple) funcTriple(.param  .s32 __cudaparmf1_funcTriple)
{

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	$BB_2_0002:				/* $LDWbegin_funcTriple */ 
		ld.param.u32 %r0, [__cudaparmf1_funcTriple];
		mov.s32 %r1, %r0;
		mul.lo.s32 %r2, %r1, 3;
		st.param.s32 [__cudaretf_funcTriple], %r2;
		ret;
}
(0.005999) KernelPartitioningPass.cpp:596:  


(0.006054) KernelPartitioningPass.cpp:145:    Spill region size is 16
(0.006063) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.006068) KernelPartitioningPass.cpp:159:   block entry
(0.006077) KernelPartitioningPass.cpp:159:   block exit
(0.006084) KernelPartitioningPass.cpp:159:   block $BB_2_0002
(0.006131) KernelPartitioningPass.cpp:185:  identifying transition points
(0.006144) KernelPartitioningPass.cpp:199:   block $BB_2_0002
(0.006156) KernelPartitioningPass.cpp:229:   block $BB_2_0002
(0.006169) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = ret
(0.006177) KernelPartitioningPass.cpp:360:    terminator->toString() = ret
KernelPartitioningPTestIndirectFunctionCall: ocelot/executive/implementation/LLVMDynamicTranslationCache.cpp:1000: void executive::setupCallTargets(ir::PTXKernel&, const executive::LLVMDynamicTranslationCache&): Assertion `0 && "arbitrary function calls not yet supported"' failed.
ass:
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .s32 __cudaretf_funcTriple) funcTriple(.param  .s32 __cudaparmf1_funcTriple)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[16];

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	$BB_2_0002:				/* $LDWbegin_funcTriple */ 
		ld.param.u32 %r0, [__cudaparmf1_funcTriple];
		mov.s32 %r1, %r0;
		mul.lo.s32 %r2, %r1, 3;
		st.param.s32 [__cudaretf_funcTriple], %r2;
		ret;
	$BB_2_0002_entry:				/* entryId: 0 */ 
		bra $BB_2_0002;
	$BB_2_0002_exit:
}
(0.006314) KernelPartitioningPass.cpp:593:  Run on kernel 'funcDouble'
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .s32 __cudaretf_funcDouble) funcDouble(.param  .s32 __cudaparmf1_funcDouble)
{

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	$BB_1_0002:				/* $LDWbegin_funcDouble */ 
		ld.param.u32 %r0, [__cudaparmf1_funcDouble];
		mov.s32 %r1, %r0;
		mul.lo.s32 %r2, %r1, 2;
		st.param.s32 [__cudaretf_funcDouble], %r2;
		ret;
}
(0.006367) KernelPartitioningPass.cpp:596:  


(0.006416) KernelPartitioningPass.cpp:145:    Spill region size is 16
(0.006424) KernelPartitioningPass.cpp:152:  partitioning blocks at barriers
(0.006431) KernelPartitioningPass.cpp:159:   block entry
(0.006439) KernelPartitioningPass.cpp:159:   block exit
(0.006446) KernelPartitioningPass.cpp:159:   block $BB_1_0002
(0.006490) KernelPartitioningPass.cpp:185:  identifying transition points
(0.006501) KernelPartitioningPass.cpp:199:   block $BB_1_0002
(0.006515) KernelPartitioningPass.cpp:229:   block $BB_1_0002
(0.006528) KernelPartitioningPass.cpp:359:  transformExitTransition() - terminator->opcode = ret
(0.006535) KernelPartitioningPass.cpp:360:    terminator->toString() = ret
KernelPartitioningPass:
/*
* Ocelot Version : 2.0.896
*/
.visible .func (.param  .s32 __cudaretf_funcDouble) funcDouble(.param  .s32 __cudaparmf1_funcDouble)
{
	.local .u32 _Zocelot_resume_point[1];
	.local .u32 _Zocelot_resume_status[1];
	.local .b8 _Zocelot_spill_area[16];

	.reg .u32 %r0;
	.reg .u32 %r1;
	.reg .u32 %r2;
	$BB_1_0002:				/* $LDWbegin_funcDouble */ 
		ld.param.u32 %r0, [__cudaparmf1_funcDouble];
		mov.s32 %r1, %r0;
		mul.lo.s32 %r2, %r1, 2;
		st.param.s32 [__cudaretf_funcDouble], %r2;
		ret;
	$BB_1_0002_entry:				/* entryId: 0 */ 
		bra $BB_1_0002;
	$BB_1_0002_exit:
}
(0.006665) LLVMDynamicExecutionManager.cpp:60:     loaded. Executing grid 1, 1
(0.006673) LLVMDynamicExecutionManager.cpp:61:     block dim: 32, 1, 1
(0.006679) LLVMDynamicExecutionManager.cpp:62:     entry id: 65536
(0.006687) LLVMDynamicExecutionManager.cpp:63:     local memory size: 216 bytes
(0.006694) LLVMDynamicExecutionManager.cpp:64:     shared memory size: 0 bytes 
(0.006703) LLVMDynamicExecutionManager.cpp:70:   Executing CTA 0, 0
(0.006711) LLVMDynamicExecutive.cpp:140:  addCta() - 0
(0.006721) LLVMDynamicExecutive.cpp:64:   CTA::initialize() - localMemorySize: 216, total threads: 32, shared memory size: 0
(0.006738) LLVMDynamicExecutive.cpp:207:  execute()
(0.006751) LLVMDynamicExecutive.cpp:340:  formed warp of size 2 with entryId 65536
(0.006758) LLVMDynamicExecutive.cpp:218:   formed warp with 2 threads
(0.006768) LLVMDynamicExecutive.cpp:235:  

Executing warp of size 2 on hyperblockId 65536
(0.006778) LLVMDynamicExecutive.cpp:383:   getOrInsertTranslationById( id: 65536, ws: 2)
(0.006786) LLVMDynamicExecutive.cpp:402:  no translation found for hyperblock id. Querying global translation cache.
(0.006792) LLVMDynamicExecutionManager.cpp:84:   LLVMDynamicExecutionManager::getOrInsertTranslation( id: 65536, warpsize: 2)
(0.006800) LLVMDynamicExecutionManager.cpp:98:   Locking dynamic execution manager

INFO     
Passing tests:
 (0.032s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestPTXToLLVMTranslator : Passed
 (0.030s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCalVectorScale : Passed
 (0.031s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLLVMInstructions : Passed
 (0.034s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestInstructions : Passed
 (0.025s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestDataflowGraph : Passed
 (0.031s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLexer : Passed
 (0.039s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestConvergence : Passed
 (0.041s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaMalloc : Passed
 (0.046s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestKernels : Passed
 (0.026s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestParser : Passed
 (0.025s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestEmulator : Passed

Failing tests:
 (0.033s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestIndirectFunctionCall : Did not complete.
 (0.042s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaGlobals : Did not complete.
 (0.038s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaTexture2D : Did not complete.
 (0.031s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestDeviceSwitching : Did not complete.
 (0.062s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaSequence : Did not complete.
 (0.041s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestPTXAssembly : Did not complete.
 (0.056s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestLLVMKernels : Did not complete.
 (0.047s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestFunctionCall : Did not complete.
 (0.035s) : /home/akerr/repositories/gpuocelot/branches/ocelot-vector-ptx2.1/TestCudaTextureArray : Did not complete.

