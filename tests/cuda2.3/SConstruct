# \file SConstruct
#
# \author Andrew Kerr <arkerr@gatech.edu>
# \date December 13, 2011
#
# \brief SConstruct for CUDA 2.3 examples to be used as a model for other tools

import os

import inspect
import platform
import re
import subprocess
from SCons import SConf


def getCudaPaths():
	"""Determines CUDA {bin,lib,include} paths
	
	returns (bin_path,lib_path,inc_path)
	"""

	# determine defaults
	if os.name == 'nt':
		bin_path = 'C:/CUDA/bin'
		lib_path = 'C:/CUDA/lib'
		inc_path = 'C:/CUDA/include'
	elif os.name == 'posix':
		bin_path = '/usr/local/cuda/bin'
		lib_path = '/usr/local/cuda/lib'
		inc_path = '/usr/local/cuda/include'
	else:
		raise ValueError, 'Error: unknown OS.  Where is nvcc installed?'
	 
	if platform.machine()[-2:] == '64':
		lib_path += '64'

	# override with environement variables
	if 'CUDA_BIN_PATH' in os.environ:
		bin_path = os.path.abspath(os.environ['CUDA_BIN_PATH'])
	if 'CUDA_LIB_PATH' in os.environ:
		lib_path = os.path.abspath(os.environ['CUDA_LIB_PATH'])
	if 'CUDA_INC_PATH' in os.environ:
		inc_path = os.path.abspath(os.environ['CUDA_INC_PATH'])

	return (bin_path,lib_path,inc_path)
	
def InitializeEnvironment():
	env = Environment()

	# get CUDA paths
	(cuda_exe_path, cuda_lib_path, cuda_inc_path)  = getCudaPaths()
	
	print "cuda_inc_path = ", cuda_inc_path
	
	env.Append(CPPFLAGS=['-Wall', '-O2', '-I.', '-I./sdk', '-I' + cuda_inc_path, '-std=c++0x'])
	
	# CUDA builder
	nvccPath = cuda_exe_path + ('/' if cuda_exe_path != '' else '')
	env.Append(BUILDERS = {'Cuda': Builder(
		action= nvccPath + 'nvcc -I' + cuda_inc_path + ' -I./sdk -arch=sm_20 $SOURCE -c -o $TARGET',
		suffix = '.o',
		src_suffix = '.cu'
	)})
	return env

# 
# Applies build rules to CUDA sources
#
def MapSource(env, source):
	if source[-3:] == ".cu":
		return env.Cuda(source)
	return source

#
# libsdk
#


env = InitializeEnvironment()

sources = [
	'sdk/stopwatch_linux.cpp',
	'sdk/cmd_arg_reader.cpp',
	'sdk/cutil.cpp',
	'sdk/stopwatch.cpp',
	'sdk/bank_checker.cpp',
]

libsdk = env.StaticLibrary('libsdk.a', sources)

#
#
#


# Declare test applications here.
#
# (appname, [sources])   -- assumes sources in "tests/{appname}/"
# (appname, [sources], path)   -- assumes sources in "tests/{path}/"
#
testApplications = [
	('3DFD', ['3dfd.cu',]),
	('worleyTestExternalSharedMemory', 
		['worleyTestExternalSharedMemory.cu',]),
	('SortingNetwork', 
		['bitonicSort.cu', 'oddEvenMergeSort.cu', 'main.cpp', 'sortingNetworks_validate.cpp']),
	('vectorAdd', ['vectorAdd.cu',]),
	('AtomicPerformance', ['atomicsImplementation.cpp', 'atomics.cpp']),
	('TestMemoryAccesses', ['TestMemoryAccesses.cpp',]),
	('TestBarriers', ['TestBarriers.cpp',]),
	('TestCallLatency', ['TestCallLatency.cpp',]),
	('TestSpecialFunctions', ['TestSpecialFunctions.cpp',]),
	('TestInstructionThroughput', ['TestInstructionThroughput.cpp',]),
	('TestThrustArbitraryTransform', ['arbitrary_transformation.cu',], 'thrust_arbitrary_transformation'),
	('TestThrustBasicVector', ['basic_vector.cu',], 'thrust_basic_vector'),
	('TestThrustBoundingBox', ['bounding_box.cu',], 'thrust_bounding_box'),
	('TestThrustBucketSort2D', ['bucket_sort2d.cu',], 'thrust_bucket_sort2d'),
	('TestThrustConstantIterator', ['constant_iterator.cu',], 'thrust_constant_iterator'),
	('TestThrustCountingIterator', ['counting_iterator.cu',], 'thrust_counting_iterator'),
	('TestThrustZipDot', ['dot_products_with_zip.cu',], 'thrust_dot_products_with_zip'),
	('TestThrustFillCopy', ['fill_copy_sequence.cu',], 'thrust_fill_copy_sequence'),
	('TestThrustHistogram', ['histogram.cu',], 'thrust_histogram'),
	('TestThrustMaxAbsDiff', ['max_abs_diff.cu',], 'thrust_max_abs_diff'),
	('TestThrustMinMax', ['minmax.cu',], 'thrust_minmax'),
	('TestThrustMode', ['mode.cu',], 'thrust_mode'),
	('TestThrustNorm', ['norm.cu',], 'thrust_norm'),
	('TestThrustPaddedGridReduction', ['padded_grid_reduction.cu',], 'thrust_padded_grid_reduction'),
	('TestThrustSaxpy', ['saxpy.cu',], 'thrust_saxpy'),
	('TestThrustSort', ['sort.cu',], 'thrust_sort'),
	('TestThrustAOSSorting', ['sorting_aos_vs_soa.cu',], 'thrust_sorting_aos_vs_soa'),
	('TestThrustStreamCompact', ['stream_compaction.cu',], 'thrust_stream_compaction'),
	('TestThrustSum', ['sum.cu',], 'thrust_sum'),
	('TestThrustTransformIterator', ['transform_iterator.cu',], 'thrust_transform_iterator'),
	('TestThrustWrapPointer', ['wrap_pointer.cu',], 'thrust_wrap_pointer'),
	('TestThrustUnwrapPointer', ['unwrap_pointer.cu',], 'thrust_unwrap_pointer'),
]

#
# Construct build rules for all tests
#
for testApplication in testApplications:
	path = testApplication[0] if len(testApplication) == 2 else testApplication[2]
	env.Program(testApplication[0], 
		[MapSource(env, 
			"tests/%s/%s" % (path, x)) for x in testApplication[1]], 
		LIBS=['-locelot', libsdk])


